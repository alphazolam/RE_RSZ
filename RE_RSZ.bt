//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: RE_RSZ.bt
//   Authors: alphaZomega w/ help from Darkness and Praydog
//   Version: 0.75
//   Purpose: Parsing RE Engine RSZ data
//  Category: RE Engine
// File Mask: *.user.2;*.pfb.*;*.scn.*;*.rcol.*;*.bhvt.*;*.motfsm2.*;*.fsmv2.*
//  ID Bytes: 
//   History: June 18, 2022
//      Note: It is recommended to use this template with 010 Editor v9.0.2 or v10.0.2, to avoid crashes
//------------------------------------------------

//              Option:                                                            //Effect:
local string    RSZVersion       <hidden=true>        = "MHRise";                  //change between RE2, RE3, RE8, DMC5 or MHRise
local int       RTVersion        <hidden=true>        = TRUE;                      //Use Ray-Tracing Update file formats for RE7, RE2R and RE3R (subject to AutoDetectGame)
local int       Nesting          <hidden=true>        = TRUE;                      //Attempt to nest class instances inside eachother
local int       ShowAlignment    <hidden=true>        = FALSE;                     //Show metadata for each variable
local int       ShowChildRSZs    <hidden=true>        = FALSE;                     //Show all RSZs one after another, non-nested. Disabling hides nested RSZHeaders
local int       UseSpacers       <hidden=true>        = TRUE;                      //Show blank rows between some structs
local int       AutoDetectGame   <hidden=true>        = TRUE;                      //Automatically detect RSZVersion based on the name + ext of the file being viewed
local int       RedetectBHVT     <hidden=true>        = TRUE;                      //Will automatically redetect the next BHVT node if there is a problem 
local int       HideRawData      <hidden=true>        = FALSE;                     //Hides RawData struct
local int       HideRawNodes     <hidden=true>        = TRUE;                      //Hides RawNodes struct
local int       SortRequestSets  <hidden=true>        = TRUE;                      //Sorts RCOL RequestSets by their IDs
local int       ExposeUserDatas  <hidden=true>        = TRUE;                      //Makes RSZFiles that contain embedded userDatas start after the Userdatas, for ctrl+J jump
local int       SeekByGameObject <hidden=true>        = FALSE;                     //Will automatically seek between detected GameObjects to fix reading errors

//Path to Noesis.exe
local wstring NoesisPath <hidden=true> =              "C:\\Program Files\\noesis\\Noesis.exe";

//Game							                      //Extracted Path
local wstring DMC5Path <hidden=true>   =              "F:\\modmanager\\REtool\\DMC_chunk_000\\natives\\x64\\";
local wstring RE2Path <hidden=true>    =              "F:\\modmanager\\REtool\\RE2_chunk_000\\natives\\x64\\";
local wstring RE3Path <hidden=true>    =              "F:\\modmanager\\REtool\\RE3_chunk_000\\natives\\stm\\";
local wstring RE7Path <hidden=true>    =              "F:\\modmanager\\REtool\\RE7_chunk_000\\natives\\x64\\";
local wstring RE8Path <hidden=true>    =              "F:\\modmanager\\REtool\\RE8_chunk_000\\natives\\stm\\";
local wstring MHRPath <hidden=true>    =              "F:\\modmanager\\REtool\\MHR_chunk_000\\natives\\stm\\";
local wstring RE2RTPath <hidden=true>  =              "F:\\modmanager\\REtool\\RE2RT_chunk_000\\natives\\stm\\";
local wstring RE3RTPath <hidden=true>  =              "F:\\modmanager\\REtool\\RE3RT_chunk_000\\natives\\stm\\";
local wstring RE7RTPath <hidden=true>  =              "F:\\modmanager\\REtool\\RE7RT_chunk_000\\natives\\stm\\";

//RSZ Parser By Darkness:
#link "RSZParser.dll"
ubyte   IsInitialized();
void    ParseJson(string jsonPath);
string  GetRSZClassName(uint32 classHash);
uint32  GetFieldCount(uint32 classHash);
uint32  GetFieldAlignment(uint32 classHash, uint32 fieldIndex);
ubyte   GetFieldArrayState(uint32 classHash, uint32 fieldIndex);
string  GetFieldName(uint32 classHash, uint32 fieldIndex);
string  GetFieldTypeName(uint32 classHash, uint32 fieldIndex);
string  GetFieldOrgTypeName(uint32 classHash, uint32 fieldIndex);
uint32  GetFieldSize(uint32 classHash, uint32 fieldIndex);
uint64  GetFieldType(uint32 classHash, uint32 fieldIndex);
ubyte   IsFieldNative(uint32 classHash, uint32 fieldIndex);
#endlink

#include "enums.hpp"

//Local variables:
local int i <hidden=true>, j <hidden=true>, k <hidden=true>, m <hidden=true>, n <hidden=true>, o <hidden=true>, h <hidden=true>, temp <hidden=true>,
            matchSize <hidden=true>, lastGameObject <hidden=true>, uniqueHashes[5000] <hidden=true>, hashesLen <hidden=true>, noRetry <hidden=true>;
local uint RSZOffset <hidden=true> = FindFirst("RSZ",1,0,0,0.0,1,0,0,24);
local uint BHVTStart <hidden=true> = FindFirst("BHVT",1,0,0,0.0,1,0,0,24);
local int UVARStart <hidden=true> = BHVTStart;
local uint lastVarEnd <hidden=true>;
local uint realStart <hidden=true> = -1;
local int level <hidden=true>;
local int finished <hidden=true>;
local int broken <hidden=true>;
local ubyte silenceMessages <hidden=true>;
local string s <hidden=true>;
local wstring tempWString <hidden=true>;
local ubyte isAIFile <hidden=true>;
local char magic[4] <hidden=true>;
local ushort headerStringsCount <hidden=true>; 
local uint headerStrings[1 + RSZOffset / 64] <hidden=true>;
local uint dummyArr[1] <hidden=true>;
local byte PasteBuffer[100000] <hidden=true>; //100KB buffer

if (detectedHash(4) && !detectedHash(0))
    ReadBytes(magic, 4, 4);
else 
    ReadBytes(magic, 0, 4);

if (ShowAlignment) {
    local int varLen <hidden=false>;
    local uint maxVars <hidden=true> = ((FileSize()-RSZOffset)/6); 
    if (maxVars > 1000000) maxVars = 1000000;
    local uint offs[maxVars] <hidden=false>, aligns[maxVars] <hidden=false>, sizes[maxVars] <hidden=false>; //synced
} else {
    local int varLen <hidden=true>;
}

local string filename <hidden=true> = GetFileName();
local wstring extractedDir <hidden=true> = DMC5Path;
local wstring Local_Directory  <hidden=true> = FileNameGetPath(filename, true);
local uint findValue <hidden=true> = find(Local_Directory, "natives");
Local_Directory = StrDel( Local_Directory, findValue, sizeof(Local_Directory) - findValue) + "natives\\";
local wstring dir <hidden=true> = Lower(Local_Directory);

if (AutoDetectGame) {
        
    checkHashesForRT();
    
    if (RTVersion && (findS(filename, "scn\\.1[89]$")!=-1 || findS(filename, "pfb\\.16$")!=-1 || findS(filename, "motfsm2\\.30$")!=-1 
    || findS(filename, "rcol\\.10$")!=-1 || findS(filename, "fsmv2\\.30$")!=-1 || findS(filename, "rcol\\.2$")!=-1)) {
        Printf("Detected Pre-RayTracing file extension\n");
        RTVersion = false;
    }
    
    local string xFmt <hidden=true> = "x64\\";
    if (find(dir, "dmc") != -1 || find(dir, "evil may") != -1) {
	    RSZVersion = "DMC5";
	    extractedDir = DMC5Path;
        Printf("Detected DMC in filepath\n");
    } else if (find(dir, "re2") != -1 || find(dir, "evil 2") != -1) {
        RSZVersion = "RE2";
        if (RTVersion) {
	        extractedDir = Lower(RE2RTPath);
	        xFmt = "stm\\";
        } else {
	        extractedDir = Lower(RE2Path);
	        xFmt = "x64\\";
        }
        Printf("Detected RE2 in filepath\n");
    } else if (find(dir, "re3") != -1 || find(dir, "evil 3") != -1) {
	    RSZVersion = "RE3";
        if (RTVersion) 
	        extractedDir = Lower(RE3RTPath);
        else 
	        extractedDir = Lower(RE3Path);
        xFmt = "stm\\";
        Printf("Detected RE3 in filepath\n");
    } else if (find(dir, "re8") != -1 || find(dir, "evil 8") != -1 || find(dir, "illage") != -1) {
	    RSZVersion = "RE8";
	    extractedDir = Lower(RE8Path);
	    xFmt = "stm\\";
        Printf("Detected RE8 in filepath\n");
    } else if (find(dir, "re7") != -1 || find(dir, "evil 7") != -1) {
	    RSZVersion = "RE7";
        if (RTVersion) {
	        extractedDir = Lower(RE7RTPath);
	        xFmt = "stm\\";
        } else {
	        extractedDir = Lower(RE7Path);
	        xFmt = "x64\\";
        }
        Printf("Detected RE7 in filepath\n");
    } else if (find(dir, "\\mhr") != -1 || find(dir, "nter R") != -1 || find(dir, "Rise") != -1) {
	    RSZVersion = "MHRise";
	    extractedDir = Lower(MHRPath);
	    xFmt = "stm\\";
        Printf("Detected MHRise in filepath\n");
    } 
	Local_Directory += xFmt;

} else if ((!RTVersion && (RSZVersion == "RE2" || RSZVersion == "RE7")) || RSZVersion == "DMC5") {
    Local_Directory += "x64\\";
} else {
    Local_Directory += "stm\\";
}

LittleEndian();
RTVersion = (RSZVersion=="RE2" || RSZVersion=="RE7" || RSZVersion=="RE3") * RTVersion;
Local_Directory = Lower(Local_Directory);
local string JsonPath <hidden=true> = Lower(FileNameGetPath(GetTemplateFileName()) + "rsz" + RSZVersion); 
if (RTVersion)
    JsonPath = JsonPath + "rt";
JsonPath = JsonPath + ".json";
ParseJson(JsonPath);

if (RSZOffset > -1 && AutoDetectGame && !(RSZVersion == "RE7" && !RTVersion))
    AutoDetectVersion();

local string VisibleRSZVersion <name="Game Version"> = RSZVersion;
if (RTVersion)
    local int VisibleRT <name="Ray Tracing Version"> = RTVersion;

//============================
//Special functions & structs:

void checkHashesForRT() {
    local int firstGameObj = FindFirst(3372393495, 1,0,0,0.0,1,0,0,24); //via.GameObject
    local int firstFolder = FindFirst(2929908172, 1,0,0,0.0,1,0,0,24);  //via.Folder
    local int firstFSM = FindFirst(4193703126, 1,0,0,0.0,1,0,0,24);     //via.motion.Fsm2ActionPlayMotion
    local int firstRCOL = FindFirst(374943849, 1,0,0,0.0,1,0,0,24);     //via.physics.UserData
    if (firstGameObj != -1) {
        RTVersion = (ReadUInt(firstGameObj+4) == 216572408); //check if CRC version is new
    } else if (firstFolder != -1) {
        RTVersion = (ReadUInt(firstFolder+4) == 2121287109);
    } else if (firstFSM != -1) {
        RTVersion = (ReadUInt(firstFSM+4) == 1025596507);
    } else if (firstRCOL != -1) {
        RTVersion = (ReadUInt(firstRCOL+4) == 3745134019);
    }
}

void AutoDetectVersion() {
    local string hashName;
    local uint checkedVersions, instanceCount, objectCount, hash, zz, varsChecked;
    local int origRTVersion = RTVersion;
    local string origVersion = RSZVersion, origExtractedDir = (string)extractedDir, origXFmt = xFmt,
        origLocal_Directory = Local_Directory, origJsonPath = JsonPath; 
    
    FSeek(RSZOffset);
    if (FTell() + 12 < FileSize())
        instanceCount = ReadUInt(FTell() + 12), objectCount = ReadUInt(FTell() + 8);
    if (instanceCount) {
        FSeek(ReadUInt(RSZOffset+24) + RSZOffset + 8);
        //if (ReadUInt64() != 0) {
        //    if (RSZVersion != "RE7")
        //        Printf("RSZVersion auto detected to RE7\n");
        //    RSZVersion = "RE7"; extractedDir = RE7Path; xFmt = "x64\\";
        //    return;
        //}
        
        for (zz=1; zz<instanceCount; zz++) {
            if (varsChecked > 100) break;
            hash = ReadUInt();
            hashName = ReadHashName(hash);
            checkedVersions = 0;
            if (hash != 0 && checkedVersions < 5 && hashName == "Unknown Class!") {
                Printf("%s %i %i\n", hashName, zz, FTell());
                while (checkedVersions < 5 && hashName == "Unknown Class!") {
                    switch (checkedVersions) {
                        case 0: RSZVersion = "DMC5"; extractedDir = DMC5Path; xFmt = "x64\\"; break;
                        case 1: RSZVersion = "RE2"; extractedDir = RE2Path; xFmt = "x64\\"; break;
                        case 2: RSZVersion = "RE3"; extractedDir = RE3Path; xFmt = "stm\\"; break;
                        case 3: RSZVersion = "RE8"; extractedDir = RE8Path; xFmt = "stm\\"; break;
                        case 4: RSZVersion = "MHRise"; extractedDir = MHRPath; xFmt = "stm\\"; break;
                        //case 5: RSZVersion = "RE2"; extractedDir = RE2RTPath; xFmt = "stm\\"; RTVersion=true; break;
                        //case 6: RSZVersion = "RE3"; extractedDir = RE3RTPath; xFmt = "stm\\"; RTVersion=true; break;
                        //case 7: RSZVersion = "RE7"; extractedDir = RE7RTPath; xFmt = "stm\\"; RTVersion=true; break;
                        //case 8: RSZVersion = "RE7"; extractedDir = RE7Path; xFmt = "x64\\"; break;
                    }
                    
                    Local_Directory = dir + xFmt; 
                    JsonPath = Lower(FileNameGetPath(GetTemplateFileName()) + "rsz" + RSZVersion);
                    if (RTVersion) JsonPath = JsonPath + "rt"; JsonPath = JsonPath + ".json";
                    ParseJson(JsonPath);
                    hashName = ReadHashName(hash);
                    checkedVersions++;
                }
                if (hashName == "Unknown Class!") { //checkedVersions == 8 && 
                    RSZVersion = origVersion; extractedDir = origExtractedDir; xFmt = origXFmt; 
                    Local_Directory = origLocal_Directory; JsonPath = origJsonPath; RTVersion = OrigRTVersion;
                } else {
                    Printf("RSZVersion auto detected to %s\n", RSZVersion);
                    break;
                }
            } //else
              //  Printf("%s\n", hashName);
            varsChecked++;
            FSkip(8);
            if (varsChecked > 15) 
                break;
        }
    }
    FSeek(0);
}


void align(uint alignment) { 
    while (FTell() % alignment != 0 && FTell() <= FileSize()) 
    FSkip(1); 
}

int detectedColorVector(uint64 tell) { 
    if (tell+16<=FileSize()) {
        local float R = ReadFloat(tell), G = ReadFloat(tell+4), B = ReadFloat(tell+8), A = ReadFloat(tell+12); 
        return ((R >= 0 && G >= 0 && B >= 0 && (A == 0 || A == 1)) && ((R+G+B+A <= 4) || (R+G+B+A) % 1.0 == 0));
    } return 0;
}

float readColorFloat(uint64 tell) {
	local float colorFlt = ReadFloat(tell); 
    if (colorFlt <= 1) {
        colorFlt = (uint)(colorFlt * 255.0f + 0.5);
	    if (colorFlt > 255) 
		    return 255;
    }
	return colorFlt ; 
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        if (BHVTStart != -1)
            return (ReadUByte(offset+3) < 255 && (Abs(flt) > 0.000001 && Abs(flt) < 100000) || ReadInt(offset) == 0); 
        else return (ReadUByte(offset+3) < 255 && (Abs(flt) > 0.0000001 && Abs(flt) < 10000000) || ReadInt(offset) == 0);
    } return false;
}

int detectedStringSm(uint64 offset) {
    if (offset+4 <= FileSize())
        if (ReadUShort(offset-2) == 0)
            if (ReadByte(offset) != 0 || ReadUShort(offset) == 0)
                if (ReadByte(offset + 1) == 0 || sizeof(ReadWString(offset)) > 5) 
                    //if (sizeof(ReadWString(offset)) >= 2)
                        return true;
    return false;
}

int detectedString(uint64 offset) { 
    if (offset+6 <= FileSize())
        if (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0) 
            if (ReadByte(offset + 2) != 0 && ReadByte(offset + 3) == 0)
                if (ReadByte(offset + 4) != 0) // && ReadByte(offset + 5) == 0
                    return true;
    return false;
}

int detectedNode (uint tell) {
    if (tell+12<FileSize())
        if (ReadInt(tell-4) == 0)
            if (ReadInt(tell) != -1) 
                if (detectedHash(tell))
                    if (ReadInt(tell+8) != 0)
                        if (detectedStringSm(startof(Header.BHVT.mNamePool) + 4 + (ReadUInt(tell+8)*2)))
                            return true;
    return false;
}

int find(wstring str, wstring term) { return (RegExSearch(str, term, matchSize, 0)); }

int findS(string str, string term) { return (RegExSearch(str, term, matchSize, 0)); }

wstring Lower(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToLower(s[k]); return s2; }

wstring Upper(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToUpper(s[k]); return s2; }

int detectedBools(uint tell) {
    local uint nonBoolTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) > 1)
            nonBoolTotal++;
    if (nonBoolTotal == 0)
        return true;
    return false;
}

int detectedHash(uint tell) {
    local uint tst = ReadInt(tell);
    if (tst == -1 || tst == 0)
        return false;
    local ubyte nonHashTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) == 0)
            nonHashTotal++;
    if (nonHashTotal <= 1)
        return true;
    return false;
}

void FileOpener(wstring path) { 
    local wstring tmpNm = GetTemplateFileNameW();
    if (FileExists(NoesisPath) && (find(path, ".mesh.") != -1 || find(path, ".tex.") != -1)) {
        Exec(NoesisPath, "\"" + path + "\"", 0);
	    FileOpen(path, TRUE, "hex", 0); 
    } else FileOpen(path, TRUE, "hex", 0);
    FileSelect(FindOpenFileW(path));
	if (GetTemplateFileNameW() == "")
		RunTemplate(tmpNm, 0);
}

typedef byte BLANK <name=readBLANK, read=readBLANK>;

    string readBLANK(BLANK &ref) { return " ";}

    string ReadErrorNotice(BLANK &b) { return "[Read Error Adjustment]"; }

    string ReadUserDataNotice(BLANK &b) { return "[Embedded UserDatas]"; }

    string ReadMainDataNotice(BLANK &b) { return "[Main Data]"; }

    void checkUseSpacers() { //this is used a lot to make things more readable and to make <open=true> work when at the end of a list
        if (UseSpacers) {
            FSkip(-1); 
            BLANK blank;
        }
    }

typedef enum {
    id_All = -1,
    id_Actions = 0,
    id_Selectors = 1,
    id_SelectorCallers = 2,
    id_Conditions = 3,
    id_TransitionEvents = 4,
    id_ExpressionTreeConditions = 5,
    id_StaticActions = 6,
    id_StaticSelectorCallers = 7,
    id_StaticConditions = 8,
    id_StaticTransitionEvents = 9,
    id_StaticExpressionTreeConditions = 10,
    id_Transition = 11,
    id_Paths = 12,
    id_Tags = 13,
    id_NameHash = 14
} BHVTlvl;

typedef enum <uint32> {
	ukn_error = 0,
	ukn_type,
	not_init,
	class_not_found,
	out_of_range,
	Undefined_tid,
	Object_tid,
	Action_tid,
	Struct_tid,
	NativeObject_tid,
	Resource_tid,
	UserData_tid,
	Bool_tid,
	C8_tid,
	C16_tid,
	S8_tid,
	U8_tid,
	S16_tid,
	U16_tid,
	S32_tid,
	U32_tid,
	S64_tid,
	U64_tid,
	F32_tid,
	F64_tid,
	String_tid,
	MBString_tid,
	Enum_tid,
	Uint2_tid,
	Uint3_tid,
	Uint4_tid,
	Int2_tid,
	Int3_tid,
	Int4_tid,
	Float2_tid,
	Float3_tid,
	Float4_tid,
	Float3x3_tid,
	Float3x4_tid,
	Float4x3_tid,
	Float4x4_tid,
	Half2_tid,
	Half4_tid,
	Mat3_tid,
	Mat4_tid,
	Vec2_tid,
	Vec3_tid,
	Vec4_tid,
	VecU4_tid,
	Quaternion_tid,
	Guid_tid,
	Color_tid,
	DateTime_tid,
	AABB_tid,
	Capsule_tid,
	TaperedCapsule_tid,
	Cone_tid,
	Line_tid,
	LineSegment_tid,
	OBB_tid,
	Plane_tid,
	PlaneXZ_tid,
	Point_tid,
	Range_tid,
	RangeI_tid,
	Ray_tid,
	RayY_tid,
	Segment_tid,
	Size_tid,
	Sphere_tid,
	Triangle_tid,
	Cylinder_tid,
	Ellipsoid_tid,
	Area_tid,
	Torus_tid,
	Rect_tid,
	Rect3D_tid,
	Frustum_tid,
	KeyFrame_tid,
	Uri_tid,
	GameObjectRef_tid,
	RuntimeType_tid,
	Sfix_tid,
	Sfix2_tid,
	Sfix3_tid,
	Sfix4_tid,
	Position_tid,
	F16_tid,
	End_tid,
	Data_tid
} TypeIDs;


uint getAlignedOffset(uint tell, uint alignment) {
    local uint offset = tell;
    switch (alignment) {
        case 2:  offset = tell + (tell % 2); break;  //2-byte
        case 4:  offset = (tell + 3) & 0xFFFFFFFFFFFFFFFC; break;  //4-byte
        case 8:  offset = (tell + 7) & 0xFFFFFFFFFFFFFFF8; break;  //8-byte
        case 16: offset = (tell + 15) & 0xFFFFFFFFFFFFFFF0; break; //16-byte
        default: break;
    }
    return offset;
}

typedef struct(int listSize) {
    local ubyte listSize <hidden=true> = listSize;
    int Count;
} BHVTCount <read=ReadBHVTCount, write=WriteBHVTCount>;

    string ReadBHVTCount(BHVTCount &c) { local string s; SPrintf(s, "%i", c.Count); return s; }

    void WriteBHVTCount(BHVTCount &c, string s) {
        local int newCount = Atoi(s);
        if (newCount - c.Count > 0) { 
            local int k, j, padding;
            local int addedSz = ((newCount - c.Count) * 4 * c.listSize);
            
            if ( ((newCount - c.Count) * 4 * c.listSize) % 16 != 0) 
                while ((RSZOffset + addedSz + padding) % 16 != RSZOffset % 16) 
                    padding++;
            
            FixBHVTOffsets(addedSz + padding, RSZOffset);
            local int extraStateBytes;
            if (c.listSize == 6 && c.Count > 0) //states
                extraStateBytes = ((startof(parentof(c)) + sizeof(parentof(c)) - (startof(c) + 4)) - (c.Count * 4 * c.listSize));
            
            for (k=c.listSize; k>0; k--) {
                InsertBytes(startof(c) + 4 + ((c.Count*4) * k) + (extraStateBytes), 4 * (newCount - c.Count), 0);
                Printf("inserting %i bytes at %i for +%i new items\n", 4 * (newCount - c.Count), startof(c) + 4 + (c.Count*4) * k, newCount - c.Count);
            }
            if (padding)
                InsertBytes(RSZOffset+addedSz, padding, 0);
            ShowRefreshMessage("");
        }
        c.Count = newCount;
    }

void FixBHVTOffsets(int addedSz, uint insertPoint) {
    local int tt, vr, nd, nv;
    if (exists(Header.treeDataSize))
        Header.treeDataSize += addedSz;
    if (BHVTStart > 0)
        FixOffsets(0, BHVTStart, insertPoint, FileSize()+addedSz, addedSz, 0);
    FixOffsets(BHVTStart, BHVTStart+sizeof(Header.BHVT), insertPoint - BHVTStart - 8, FileSize()+addedSz, addedSz, 0);
    while(exists(RSZFile[tt])) {
        if (!RSZFile[tt].isEmbeddedUserData)
            FixOffsets(startof(RSZFile[tt]) + addedSz, startof(RSZFile[tt].RSZHeader)+48, insertPoint, FileSize()+addedSz, addedSz, 0);
        tt++;
    }
    tt=0;
    while (exists(Header.BHVT.Uvar[tt])) {
        FixOffsets(startof(Header.BHVT.Uvar[tt]), startof(Header.BHVT.Uvar[tt])+40, insertPoint-BHVTStart, FileSize()+addedSz, addedSz, 0); //Header
        if (exists(Header.BHVT.Uvar[tt].Data)) {
            FixOffsets(startof(Header.BHVT.Uvar[tt].Data), startof(Header.BHVT.Uvar[tt].Data)+sizeof(Header.BHVT.Uvar[tt].Data), insertPoint-BHVTStart, FileSize()+addedSz, addedSz, 0); //Data 
            vr=0;
            while(exists(Header.BHVT.Uvar[tt].Data.Var[vr])) {
                if (exists(Header.BHVT.Uvar[tt].Data.Var[vr].VarData)) {
                    if (Header.BHVT.Uvar[tt].Data.Var[vr].VarData.nodesOffset > 0) Header.BHVT.Uvar[tt].Data.Var[vr].VarData.nodesOffset += addedSz;
                    if (Header.BHVT.Uvar[tt].Data.Var[vr].VarData.offset2 > 0) Header.BHVT.Uvar[tt].Data.Var[vr].VarData.offset2 += addedSz; //all this because [propCount, ukn00, ukn01] sometimes make false positives for FixOffsets
                    nd = 0;
                    while(exists(Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd])) {
                        if (Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].name.strOffset > 0) Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].name.strOffset += addedSz;
                        if (Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].dataOffset > 0) Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].dataOffset += addedSz;
                        nv = 0;
                        while (exists(Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].Value[nv])) {
                            if (exists(Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].Value[nv].hashOffs)
                            && Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].Value[nv].hashOffs > 0) {
                                Header.BHVT.Uvar[tt].Data.Var[vr].VarData.Node[nd].Value[nv].hashOffs += addedSz;
                            }
                            nv++;
                        }
                        nd++;
                    }
                }
                vr++;
            }
        }
        if (exists(Header.BHVT.Uvar[tt].HashData))
            FixOffsets(startof(Header.BHVT.Uvar[tt].HashData), startof(Header.BHVT.Uvar[tt].HashData)+sizeof(Header.BHVT.Uvar[tt].HashData)
                , insertPoint-BHVTStart, FileSize()+addedSz, addedSz, 0); //Hashes
        if (exists(Header.BHVT.Uvar[tt].EmbeddedUVARs))
            FixOffsets(startof(Header.BHVT.Uvar[tt].EmbeddedUVARs)+4, 4+startof(Header.BHVT.Uvar[tt].EmbeddedUVARs)+sizeof(Header.BHVT.Uvar[tt].EmbeddedUVARs.embedOffsets)
                , insertPoint-BHVTStart, FileSize()+addedSz, addedSz, 0); //embeds
        if (exists(Header.BHVT.Uvar[tt].EndOffsets))
            FixOffsets(startof(Header.BHVT.Uvar[tt].EndOffsets), startof(Header.BHVT.Uvar[tt].EndOffsets)+sizeof(Header.BHVT.Uvar[tt].EndOffsets)
                , insertPoint-BHVTStart, FileSize()+addedSz, addedSz, 0); //End Offsets
        tt++;
    }
}

void FixRCOLOffsets(uint sizeToAdd, uint insertPt, int64 limitOffset) {
    if (exists(RequestSets)) {
        //if (sizeof(RSZFile[0]) != Header.userDataSize)
        //    Header.userDataSize = sizeof(RSZFile[0]);
        FixOffsets(0, Groups.shapesEnd, insertPt, limitOffset, sizeToAdd, 0);
        FixOffsets(startof(RequestSets), startof(RequestSets)+sizeof(RequestSets), insertPt, limitOffset, sizeToAdd, 0);
    }
}

void WriteNewNode(ubyte &n, string s) {
    local int addedSz = 78;
    if (isAIFile)
        addedSz = 52;
    local int stringInsertPt = startof(Header.BHVT.mNamePool)+sizeof(Header.BHVT.mNamePool);
    local int nodeInsertPt = startof(BehaviorTree.RawNodes)+sizeof(BehaviorTree.RawNodes);
    local uint newHash = hash_wide(s);
    local int existingPadding, stringPadding, nodePadding;
    local int stringSz = sizeof(s)*2;
    nodePadding = 16 - (addedSz % 16);
    while(ReadUByte(stringInsertPt+existingPadding) == 0)
        existingPadding++;
    while((stringInsertPt + stringSz + stringPadding) % 16 != stringInsertPt % 16)
        stringPadding++;
    if (existingPadding + stringPadding > 16)
        stringPadding -= 16;
    FixBHVTOffsets(stringSz + stringPadding, stringInsertPt); // - stringPadding
    FixBHVTOffsets(addedSz + nodePadding, RSZOffset); //-64
    Header.BHVT.mNamePool.poolSize += sizeof(s);
    SetCursorPos(stringInsertPt);
    if (stringPadding > 0)
        InsertBytes(stringInsertPt, stringPadding, 0);
    if (stringPadding < 0)
        DeleteBytes(stringInsertPt, -stringPadding);
    InsertBytes(stringInsertPt, stringSz, 0);
    WriteWString(stringInsertPt, s);
    InsertBytes(RSZOffset, 16 - (addedSz % 16), 0);
    InsertBytes(nodeInsertPt, addedSz, 0);
    for (i=0;i<4;i++) 
        WriteUByte(nodeInsertPt+i, Random(255)); //Random hash
    WriteUInt(nodeInsertPt+8, (stringInsertPt - startof(Header.BHVT.mNamePool)-4) / 2);
    WriteInt(nodeInsertPt+24, -1);
    WriteInt(nodeInsertPt+32, -1);
    if (!isAIFile) {
        WriteUInt(nodeInsertPt+44, 35);
        WriteUInt(nodeInsertPt+48, newHash);
        WriteUInt(nodeInsertPt+52, newHash);
    }
    BehaviorTree.NodeCount += 1;
    ShowRefreshMessage("");
}

string readNodeWriterMessage(ubyte &n) { return "      [Input a name here to add a Behavior Node]"; }

void ShowRefreshMessage(string extraMsg) {
    if (!silenceMessages)
        MessageBox( idOk, "Insert Data", "%sPress F5 to refresh the template and fix template results", extraMsg);
}

//General offset fixer
void FixOffsets(uint64 tell, uint64 tellLimit, uint64 insertPoint, int64 maxOffset, uint64 addedSz, int doInt32) {
    if (tell > tellLimit) {
        Printf("Cannot fix offsets: insert point %i is before start boundary %i\n", insertPoint, tell);
        return;
    }
    Printf("Fixing Offsets greater than %i and less than %i from positions %i to %i:\n\n", insertPoint, maxOffset, tell, tellLimit);
    local uint64 pos = FTell();
    local int64 tmp;
    local int varSize = 8 + -4 * (doInt32 > 0);
    FSeek(tell);
    while(FTell() + varSize <= tellLimit) {
        if (FTell()+varSize > FileSize()) 
            break;
        if (doInt32)
            tmp = ReadInt(FTell());
        else 
            tmp = ReadInt64(FTell());
        if (tmp >= insertPoint && tmp <= maxOffset) {
            Printf("@ position %i:  %Li  >= %Li (limit %i) added +%i\n", FTell(), tmp, insertPoint, maxOffset, addedSz);
            if (doInt32) 
                tmp = WriteUInt(FTell(), tmp + addedSz);
            else 
                WriteUInt64(FTell(), tmp + addedSz);
        }// else //if (tmp && tmp <= maxOffset)
         //   Printf("@ position %i: %Li  >! %Li (limit %i) %i\n",  FTell(), tmp, insertPoint, tellLimit, addedSz);
        FSkip(varSize);
    }
}

//Sorts array in ascending order, then sorts array2 by array (from Che)
void quicksort( int low, int high, uint array[], uint array2[] ) {
    local int i = low;
    local int j = high;
    local int temp = 0;
    local int z = array[(low + high) / 2]; // Choose a pivot value
    local byte doArray2;
    if (exists(array2[1]))
        doArray2 = true;
    while( i <= j ) { // Partition the data
        while( array[i] < z ) // Find member above
            i++;
        while( array[j] > z ) // Find element below
            j--;
        if( i <= j )  {
            // swap two elements 
            temp     = array[i];
            array[i] = array[j]; 
            array[j] = temp;
            if (doArray2) {
                temp     = array2[i];
                array2[i] = array2[j]; 
                array2[j] = temp;
            }
            i++; 
            j--;
        }
    }
    // Recurse
    if( low < j )  
        quicksort( low, j, array, array2 );
    if( i < high ) 
        quicksort( i, high, array, array2 ); 
}

int getLevel(uint offset) {
    local int L = 0;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L].Data) && offset < startof(RSZFile[L].Data) + sizeof(RSZFile[L].Data))
            break;
    return L;
}

int getLevelRSZ(uint offset) {
    local int L;
    for (L=0; L<level; L++) {
        if (offset >= startof(RSZFile[L].RSZHeader) - 16 && offset <= startof(RSZFile[L].RSZHeader) + 16)
            break;
    }
    return L;
}

typedef struct {
    uchar uuid[16] <open=suppress>;
    if (ReadInt(startof(uuid)) != -1 && ReadInt(startof(uuid)) != 0 ) {
        if (FindFirst(ReadInt(startof(uuid))) != startof(uuid) || FindFirst(ReadInt(startof(uuid)),1,0,0,0.0,1,startof(uuid)+16,0,24) != -1) {
            local string Guid <hidden=true> = TranslateGUID(uuid);
            FSkip(-4);
            struct SAMEGUIDS SameGUIDs(TranslateGUID(uuid)) <size=4>;
        }
    }
} rGUID <read=ReadrGUID, write=WriterGuid, comment=ReadrGUIDComment>;

    string TranslateGUID (uchar uuid[]) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],
            uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]
        );
        return s;
    }

    string ReadrGUID (rGUID &g) {
        local string Guid = TranslateGUID(g.uuid);
        return Guid;
    }

    string ReadrGUIDComment(rGUID &g) { if (exists(g.GameObjectRef)) return g.GameObjectRef; return ""; }

    void WriterGuid (rGUID &g, string s) {
        local string out;
        local byte ii, offset, var;
        for (ii=0; ii<16; ii++) {
            if (ii==4 || ii== 6 || ii==8 || ii==10) 
                offset++;
            SScanf(SubStr(s, ii*2 + offset, 2), "%x", var);
            WriteByte(startof(g) + ii, var);
        }
    }

//functions for opening files:
string getRE2ext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".tex": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769669";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": case ".fbxskel": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1808312334";
		case ".fsmv2": case ".bhvt": case ".motfsm2": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".lprb": return ".3";
		case ".mmtr": return ".1808160001";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

string getRE3ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".12";
		case ".pfb": return ".17";
		case ".mdf2": return ".13";
		case ".tex": return ".190820018";
		case ".rcol": case ".jmap": return ".11";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1902042334";
		case ".fsmv2": case ".bhvt": case ".tml": case ".clip": return ".34";
		case ".motfsm2": return ".36";
		case ".scn": return ".20";
		case ".mov": return ".1";
		case ".chain": return ".24";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".99";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".78";
		case ".gui": return ".340020";
		case ".rmesh": return ".17008";
		case ".rtex": return ".4";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".14";
		case ".msg": return ".15";
		default: return "";
	}
}

string getRE7ext(wstring ext) {
	switch (ext) {
        case ".uvar": case ".lprb": case ".rcol": case ".mcol": case ".wcc": case ".wss": case ".ies": return ".2";
		case ".pfb": return ".16";
		case ".mdf2": return ".6";
        case ".efx": return ".1179750";
        case ".tex": case ".jmap": case ".aimap": return ".8"; 
		case ".wel":   return ".10";
		case ".mesh": return ".32";
		case ".fsm": case ".motfsm": return ".17";
		case ".scn": case ".tml": return ".18";
		case ".motbank": return ".1";
        case ".mov": return ".1.x64";
		case ".chain": return ".5";
		case ".mmtr": return ".69";
		case ".motlist": return ".60";
		case ".cfil": return ".3";
        case ".uvs":  return ".5";
		case ".mot": return ".17";
		case ".gui": return ".180014";
		case ".rtex": return ".4";
		case ".mcamlist": return ".7";
        case ".msg": return ".12";
        case ".clo": return ".2016100701";
        case ".rbd": case ".rdl": return ".2016100700";
		default: return "";
	}
}

string getRE8ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".16";
		case ".pfb": return ".17";
		case ".mdf2": return ".19";
		case ".tex": return ".30";
		case ".rcol": return ".18";
		case ".jmap": return ".17";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".2101050001";
		case ".bhvt": case ".tml": return ".34";
		case ".fsmv2": case ".clip": return ".40";
		case ".motfsm2": return ".42";
		case ".scn": return ".20";
		case ".mov": case ".finf": return ".1";
		case ".chain": return ".39";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".486";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".458";
		case ".gui": return ".400023";
		case ".rmesh": return ".17008";
		case ".rtex": return ".5";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".17";
		case ".msg": return ".15";
		case ".gpuc": return ".62";
		default: return "";
	}
}

string getMHRext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".10019";
		case ".jcns": return ".14";
		case ".pfb": return ".17";
		case ".mdf2": return ".19";
		case ".tex": return ".28";
		case ".rcol": return ".18";
		case ".jmap": return ".16";
		case ".lprb": return ".4";
		case ".efx": return ".2621987";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".2008058288";
		case ".bhvt": case ".tml": return ".34";
		case ".fsmv2": case ".clip": return ".40";
		case ".motfsm2": return ".42";
		case ".scn": return ".20";
		case ".mov": case ".finf": return ".1";
		case ".chain": return ".35";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".486";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".458";
		case ".gui": return ".400023";
		case ".rmesh": return ".17008";
		case ".rtex": return ".5";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".17";
		case ".msg": return ".15";
		case ".gpuc": return ".62";
        case ".iklookat2": return ".8";
		default: return "";
	}
}

string getDMCext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769672";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": return ".2";
		case ".wel": case ".tex":  return ".11";
		case ".mesh": return ".1808282334";
		case ".fsmv2": case ".bhvt": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".fbxskel": case ".lprb": return ".3";
		case ".motfsm2": return ".31";
		case ".mmtr": return ".1808168797";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

//convert a filepath string to Windows format:
string MakeBackslashes (wstring path, ubyte reverse) { //vfx
	local wstring localPath <hidden=true> = path;
    local wstring Char = "/", revChar = "\\";
    if (reverse) {
        Char = "\\\\";
        revChar = "/";
    }
	if (find(path, "@") != -1)
		localPath = StrDel(localPath, 0, 1);
	local uint index = find(localPath, Char);
	while (index != -1) {
		localPath = StrDel(localPath, index, sizeof(localPath) - index + 1) + revChar + SubStr(localPath, index + 1, -1);
		index = find(localPath, Char);
	} 
    return localPath;
}

void ReadRSZPath(wstring data) {
	local wstring localPath <hidden=true> = data;
    
	if (RSZVersion == "DMC5") {
		localPath = MakeBackslashes(localPath, 0) + getDMCext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE3") {
		localPath = MakeBackslashes(localPath, 0) + getRE3ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE2") {
		localPath = MakeBackslashes(localPath, 0) + getRE2ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE7") {
		localPath = MakeBackslashes(localPath, 0) + getRE7ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE8") {
		localPath = MakeBackslashes(localPath, 0) + getMHRext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "MHRise") {
		localPath = MakeBackslashes(localPath, 0) + getMHRext(FileNameGetExtension(localPath));
	}  

	if (exists(fullPath)) { 
	    fullPath = Local_Directory + localPath;
	    if (Local_Directory != extractedDir && FileExists(Local_Directory + localPath)) {
		    local uint existsInMod <hidden=false> = 1;
		    fullPath = Local_Directory + localPath;
	    }
	    if (extractedDir != "" && FileExists((extractedDir + localPath))) {
		    if (exists(existsInMod)) {
			    local uint existsInPak <hidden=false> = 1;
		    } else { 
			    local uint existsInPak <hidden=true> = 1; 
			    fullPath = extractedDir + localPath;
		    }
	    }
	    if (fullPath != "" && FileExists(fullPath)) {
		    FSkip(-1);
		    ubyte OpenFile <name="OpenFile", write=WriteOpenFile, read=ReadOpenFile, open=false>;
	    }
    }
}

    string ReadOpenFile (ubyte &in) { return "Input here to open File"; }
    
    void WriteOpenFile(ubyte &in, wstring s) { FileOpener(parentof(in).fullPath); }

int detectedGuid(uint tell) {
    local int zerosCount;
    for (o=0; o<16; o++) 
        zerosCount += (ReadUByte(FTell()+o) == 0);
    return zerosCount;
}

int detectedObject(uint tell) {
    if (tell+4 <= FileSize()) {
        local int test = ReadInt(tell);
        if (test < idx && test > 0 && (test > idx - 100 || exists(userDataPath))) // && test > 2
            return true;
    }
    return false;
}

void redetectObject() {
    if (!finished && broken ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4) {
            if (detectedObject(FTell())) {
                SetForeColor(cYellow);
                Printf("Redetected object from %u to %u\n",  pos, FTell()); 
                break;
            } else FSkip(4);
        }
    }
}

void setAsBroken() {
    FSkip(-1);
    broken = true;
    SetForeColor(cNone);
    ubyte blank <hidden=true, bgcolor=cRed>;
}

void redetectFloat() {
    if (broken && FTell() + 4 <= FileSize() && (broken && !finished)) { 
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && detectedFloat(FTell()))
            FSkip(4);
        
        if (FTell() != pos && FTell() < pos + 16) {
            broken = FALSE;
            SetForeColor(cYellow);
            Printf("Redetected float from %u to %u\n",  pos, FTell()); 
        } else FSeek(pos);
    }
    if (!detectedFloat(FTell()) && ReadFloat(FTell()) != 0) {
        broken = TRUE;
        SetForeColor(cNone);
    }
}

void redetectGuid() {
    if (FTell() + 16 <= FileSize() && !finished && (detectedGuid(FTell()) >= 4)) { // && broken
        local int pos = FTell();
        //if (broken) 
        //    FSkip(-12);
        while(FTell() <= FileSize() - 16) {
            if (detectedGuid(FTell()) == 16 || (detectedGuid(FTell()) < 4 && (detectedGuid(FTell()) <= detectedGuid(FTell() + 8)))) {
                if (pos != FTell()) {
                    broken = FALSE;
                    SetForeColor(cYellow);
                    Printf("Redetected GUID from %u to %u\n",  pos, FTell()); 
                }
                break;
            } else FSkip(8);
        }
    }
}

int isValidString(uint tell) {
    local int alignedOffs = getAlignedOffset(tell, 4);
    if (alignedOffs + 4 >= FileSize())
        return false;
    local uint size = ReadUInt(alignedOffs);
    if (sizeof(ReadWString(alignedOffs+4)) == 0)
        return false;
    local wstring String = ReadWString(alignedOffs+4);
    return (alignedOffs+8 <= FileSize() && ReadUInt64(alignedOffs) == 1 || size == 0 || (size == sizeof(String)/2 && ReadUByte(alignedOffs+7 != 0)) );
}

void redetectStringBehind() {
    local int pos = FTell();
    if (detectedString(FTell())) {
        while (detectedString(FTell()) && ReadUInt(FTell()-4) != sizeof(ReadWString(FTell())) / 2) 
            FSkip(-2);
        FSkip(-4);
        if (pos == FTell() || !isValidString(FTell()) || (sizeof( ReadWString(FTell()+4)) + FTell() <= pos) ) {
            //Printf("Aborting string redetection from %u to %u\n",  pos, FTell()); 
            FSeek(pos);
            setAsBroken();
        } else if (FTell() < pos) {
            local int newPos = FTell(); FSeek(pos); BLANK blank <read=ReadErrorNotice, bgcolor=cRed>; FSeek(newPos);
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u back to %u\n",  pos, FTell()); 
        }
    } 
}

void redetectString() {
    if (!broken && !isValidString(FTell()+4)) 
        return;
    if  (FTell() + 4 <= FileSize() && ( !finished && (broken || !isValidString(FTell()) ) ) ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && FTell() - 24 < pos) {
            if (((detectedString(FTell()) && isValidString(FTell()-4)))) {
                FSkip(-4);
                break;
            } else uint skip <hidden=true>; //fgcolor=cRed,
        }
        if (FTell() - pos > 16 && broken) {
            FSeek(pos); //abort
        } else if (FTell() - pos > 8 && !broken) {
            FSeek(pos); //abort
        } else {
            local int newPos = FTell(); FSeek(pos); BLANK blank <read=ReadErrorNotice, bgcolor=cRed>; FSeek(newPos);
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u to %u\n",  pos, FTell()); 
        }
    }
}

void ForceWriteString(uint tell, uint maxSize, wstring str) {
    OverwriteBytes(tell, maxSize, 0); 
    if (str != " " && str != "")
        WriteWString(tell, str); 
}

typedef ubyte Bool <read=ReadBOOL, write=WriteBOOL>;

    wstring ReadBOOL(Bool &b) {
        if (b)
            return "True";
        return "False";
    }
    
    void WriteBOOL(Bool &b, wstring s) {
        if (find(Lower(s), "true") != -1 || Atoi(s) >= 1)
            b = 1;
        else b = 0;
    }
    
    void WriteCount (uint &c, string s) {
        InstanceWriterMethod(s, parentof(c).lvl, parentof(parentof(c)).idx, 4, 0, parentof(c).fieldIndex);
        c = Atoi(s);
    }

//main typedef for RSZ chunks:
typedef struct(uint32 classHash, ubyte fieldIndex) {
    local uint varStart <hidden=true> = FTell();
    local ubyte lvl <hidden=true> = level;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    //else if (finished)
    //    lvl = getLevel(FTell());
    local ubyte padding <hidden=true> = varStart - lastVarEnd;
    local uint32 classHash <hidden=true> = classHash;
    local ubyte fieldIndex <hidden=true> = fieldIndex;
    local string fieldName <hidden=true> = GetFieldName(classHash, fieldIndex);
    local string fieldDataType <hidden=true> = GetFieldTypeName(classHash, fieldIndex);
    local TypeIDs fieldType <hidden=true> = GetFieldType(classHash, fieldIndex);
    local ushort elementSize <hidden=true> = GetFieldSize(classHash, fieldIndex);
    local ubyte align <hidden=true> = GetFieldAlignment(classHash, fieldIndex);
    local ubyte isList <hidden=true> = GetFieldArrayState(classHash, fieldIndex);
    local int varIdx <hidden=true> = -1;
    local string fieldOrgTypeName <hidden=true> = GetFieldOrgTypeName(classHash, fieldIndex);
    
    if (!finished && ShowAlignment) {
        varIdx = varLen;
        varLen++;
        if (ShowAlignment && offs[varIdx] == 0) {
            if ( varIdx != 0 && offs[varIdx-1] >= varStart) { //new vars at the same offset overwrite old ones
                varLen--;
                varIdx--;
            } else {
                offs[varIdx] = varStart;
                aligns[varIdx] = align;
                sizes[varIdx] = -1;
            }
        }
    }

    if ((isList) && !exists(parentof(this).Count)) {
        if (FTell()+4 <= FileSize()) {
            uint Count <write=WriteCount>;
            local ushort count <hidden=true> = Count;
            if (!finished) {
                if (ShowAlignment)
                    sizes[varIdx] = 4;
                lastVarEnd = FTell();
            }
            if (Count > -1 && Count < FileSize()  && Count * elementSize <= FileSize() - FTell() ) {
                local uint c <hidden=true>, alignedOffs <hidden=true>;
                for (c=0; c<Count; c++) {
                    alignedOffs = getAlignedOffset(FTell(), align);
                    if (alignedOffs+elementSize <= FileSize()) {
                        FSeek(alignedOffs);
                        if (fieldType == Color_tid) {
                            temp = ((int)ReadUByte(FTell()+2)<<16 | (int)ReadUByte(FTell()+1)<<8 | (int)ReadUByte(FTell()));
                            SetForeColor(temp); 
                            SetBackColor(temp);
                        }
                        if (Count == 1 && (fieldType == Object_tid || (fieldType == Data_tid && detectedObject(FTell())))) {
			                struct RSZVariable var(classHash, fieldIndex) <open=true>;
                            checkUseSpacers();
                        } else
                            struct RSZVariable var(classHash, fieldIndex);
                    } else {
                        setAsBroken();
                        break;    
                    }
                }
            } else setAsBroken();
        }
	} else {
		switch (fieldType) {
			case Bool_tid:
				if (FTell()+1 <= FileSize())
				    Bool data;
				break;
			case Color_tid:
                if (FTell()+4 <= FileSize())
				    ubyte data <name="ubyte R">, data <name="ubyte G">, data <name="ubyte B">, data <name="ubyte A">;
				break;
			case F32_tid:
				fieldDataType = "Float";
				if (FTell()+4 <= FileSize())
				    float data;
				break;
			case F64_tid:
				fieldDataType = "Double";
				if (FTell()+8 <= FileSize())
				    double data;
				break;
            case PlaneXZ_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float z">;
				break;
			case Float2_tid:
			case Point_tid:
            case Segment_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float y">;
				break;
			case Float3_tid:
				if (FTell()+12 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				break;
			case Quaternion_tid:
			case Float4_tid:
				if (FTell()+16 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				break;
			case GameObjectRef_tid:
            case Guid_tid:
            case Uri_tid:
				if (FTell()+16 <= FileSize())
				    rGUID Guid;
                break;
            case DateTime_tid:
                int64 data;
                break;
            case OBB_tid:
            case AABB_tid:
            case Capsule_tid:
            case LineSegment_tid:
			case Mat4_tid:
				if (FTell()+32 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                    if (fieldType == Capsule_tid) {
                        if (FTell()+4 <= FileSize())
				            float data <name="float r">;
                    } else if (fieldType != AABB_tid) {
					    if (FTell()+32 <= FileSize()) {
				            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
					        float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (fieldType == OBB_tid && FTell()+16 <= FileSize())
                                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        } 
                    }
                }
				break;
			case UserData_tid:
            case Object_tid:
                if (FTell()+4 <= FileSize()) {
                    int ObjectIndex;
                    //FSkip(-4); int data <hidden=true>;
                }
                if (exists(ObjectIndex) && ObjectIndex > 0)
                    if (fieldType == UserData_tid) {
                        if ((!RTVersion && RSZVersion == "RE2") || RSZVersion == "DMC5") { 
                            if ((!exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]) || !exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx) || RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx == -1)) {
                                if (finished) Printf("Broken UserData at %i\n", FTell()); 
                            } else if (exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].RSZOffset_Absolute.OffsetAbs)) {
                                FSeek(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].RSZOffset_Absolute.OffsetAbs);
                                struct RSZMagic UserData <open=true, size=56, fgcolor=cNone>;
                                FSeek(startof(ObjectIndex)+4);
                                checkUseSpacers();
                                break;
                            } 
                        } else if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx) && RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx > -1) {// RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx
                            FSkip(-1);
                            struct StringRead path ( (startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx])+8), startof(RSZFile[lvl].RSZHeader), 0);
                            break;
                        } 
                    } else if (exists(ObjectIndex) && ObjectIndex > 0 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) { //fieldType == Object_tid &&  
					    FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])); 
					    struct RSZInstance RSZ <open=true, size=SizeRSZInstance>;
                        checkUseSpacers();
					    FSeek(startof(ObjectIndex)+4);
				    }
				break;
			case Range_tid:
                if (FTell()+8 <= FileSize())
				    float data <name="float R">, data <name="float S">;
				break;
			case RangeI_tid:
                if (FTell()+8 <= FileSize())
				    int data <name="int R">, data <name="int S">;
				break;
			case RuntimeType_tid:
                if (FTell()+4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size <= FileSize())
					    char data[size];
                }
				break;
			case S16_tid:
                if (FTell()+2 <= FileSize())
				    short data;
				break;
			case S32_tid:
				fieldDataType = "Int";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case Enum_tid:
				//fieldDataType = "Enum";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case S64_tid:
				fieldDataType = "Int64";
				if (FTell()+8 <= FileSize())
				    int64 data;
				break;
			case S8_tid:
				fieldDataType = "Byte";
				if (FTell()+1 <= FileSize())
				    byte data;
				break;
			case Size_tid:
				fieldDataType = "Size";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U16_tid:
				fieldDataType = "UShort";
				if (FTell()+2 <= FileSize())
				    ushort data;
				break;
			case U32_tid:
				fieldDataType = "UInt";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U64_tid:
				fieldDataType = "UInt64";
				if (FTell()+8 <= FileSize())
				    uint64 data;
				break;
			case U8_tid:
				fieldDataType = "UByte";
				if (FTell()+1 <= FileSize())
				    ubyte data;
				break;
			case Vec2_tid:
				if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">;
				    float data <hidden=true>, data <hidden=true>; //FSkip(8);
                }
				break;
			case Vec3_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				    float data <hidden=true>; //FSkip(4);
                }
				break;
			case Vec4_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                }
				break;
			case Int2_tid:
                if (FTell()+8 <= FileSize())
				    int32 data <name="int x">, data <name="int y">;
                break;
            case Int3_tid:
                if (FTell()+12 <= FileSize())
				    int32 data <name="int x">, data <name="int y">, data <name="int z">;
                break;  
            case Uint3_tid:
                if (FTell()+12 <= FileSize())
				    uint32 data <name="uint x">, data <name="uint y">, data <name="uint z">;
                break;
            case Data_tid:
            case ukn_type: 
                if (find((wstring)fieldDataType, "tring") == -1) { //if NOT a string:
                    if (elementSize == 1 ) { 
                        fieldDataType = "Byte";
                        if (FTell()+1 <= FileSize())
				            byte data;
                    } else if (elementSize == 2) {
                        fieldDataType = "Int16";
                        if (FTell()+2 <= FileSize())
				            short data;
                    } else if (elementSize == 4) {
                        fieldDataType = "Data";
                        if (FTell()+4 <= FileSize())
                            if (ReadInt(FTell()) != 0 && detectedFloat(FTell()) ) { //&& ReadUByte(FTell()+3) != 255
                                if (FTell()+4 <= FileSize()) {
				                    float data;
                                    FSkip(-4);
                                    int data_As_Int;
                                }
                            } else if (detectedObject(FTell())){
                                fieldDataType = "Data (Object?)";
                                if (FTell()+4 <= FileSize()) {
				                    int ObjectIndex <name="int data (ObjectIndex?)">;
                                    //FSkip(-4); int data <hidden=true>;
					                if (ObjectIndex > 0 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
						                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
                                        struct RSZInstance RSZ <size=SizeRSZInstance, open=true>;
                                        checkUseSpacers();
						                FSeek(startof(ObjectIndex)+4);
					                }
                                }
                            } else {
                                if (FTell()+4 <= FileSize()) {
				                    int data;
                                    FSkip(-4);
                                    float data_As_Float;
                                }
                            }
                    } else if (elementSize == 8) {
                        if (detectedFloat(FTell()) && detectedFloat(FTell()+4)) {
                            if (FTell()+8 <= FileSize())
				                float data <name="float x">, data <name="float y">;
                        } else {
                            fieldDataType = "Int64";
                            if (FTell()+8 <= FileSize())
				                int64 data;
                        }
                    } else if (elementSize == 16) {
                        if (align == 8) {
                            fieldDataType = "Guid";
                            fieldType = Guid_tid;
                            if (FTell()+16 <= FileSize())
				                rGUID Guid;
                        } else {
                            fieldDataType = "Vec4";
                            if (FTell()+16 <= FileSize())
				                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        }
                    } else if (elementSize == 64 || elementSize == 80) {
                        fieldDataType = "Mat4";
                        if (FTell()+4 <= FileSize()) {
                            float data <name="float x1">, data <name="float y1">, data <name="float z1">, data <name="float w1">;
                            float data <name="float x2">, data <name="float y2">, data <name="float z2">, data <name="float w2">;
                            float data <name="float x3">, data <name="float y3">, data <name="float z3">, data <name="float w3">;
                            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (elementSize == 80) {
                                fieldDataType = "OBB";
                                if (FTell()+16 <= FileSize())
				                    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            }
                        }
                    } else {
                        if (FTell()+elementSize <= FileSize())
                            if (elementSize % 4 == 0) {
                                local ubyte counter <hidden=true>;
                                while(counter < (uint)(elementSize / 4)) {
                                    if (detectedFloat(FTell()))
                                        float data;
                                    else int data;
                                    counter++;
                                }
                            }
				            else ubyte data[elementSize];
                    }
                    break;
                } //if it IS a string, don't break and continue on:
            
			case Resource_tid:
			case String_tid:
                fieldType = String_tid;
				fieldDataType = "String";
                FSeek(getAlignedOffset(FTell(), 4));
                if (!isList) {
                    redetectStringBehind(); 
				    FSeek(getAlignedOffset(FTell(), 4)); 
                    if (isValidString(FTell()) && ReadUInt(FTell()) != 0)
                        broken=false;
                    else redetectString();
                }
                if (FTell() + 4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size * 2 <= FileSize() )
					    wchar_t data[size] <open=suppress>;
                    if (size > 0 && !exists(data) && !detectedFloat(FTell()-4)) 
                        setAsBroken();
                    local ubyte isString <hidden=true> = TRUE;
                } else 
                    FSeek(startof(this));
				break;
            
			default:
				Printf("%u Unknown type %s in class \"%s\" (Hash: 0x%08X) field number %d returned TypeID = \"%d\" ListFlag = \"%d\"\r\n", 
                FTell(), EnumToString(fieldType), GetRSZClassName(classHash), classHash, fieldIndex, fieldType, isList);
                if (elementSize % 4 == 0)
                    float data[elementSize/4];
                else
                    ubyte data[elementSize];
				break;
		}
        if (BHVTStart != -1 && exists(data) && sizeof(data) == 4) { 
            local uint BHVTStructID = idx;
            local uint z <hidden=true>, pos <hidden=true> = FTell();
            local string RSZMagicName = ReadRSZMagicName(RSZFile[lvl]);
            
            FSeek(startof(data));
            if (BHVTStructID > 1 && (RSZMagicName == "StaticConditions" || RSZMagicName == "Conditions")) {
                if (RSZMagicName == "StaticConditions")
                    BHVTStructID += 1073741824;
                if (FindFirst(BHVTStructID,1,0,0,0.0,1,0,0,24) != -1)
                    struct {
                        local uint ID_offset <hidden=true>;
                        for (z=0; z<BehaviorTree.NodeCount; z++) {
                            ID_offset = FindFirst(BHVTStructID,1,0,0,0.0,1,startof(BehaviorTree.RawNodes.Node[z]),sizeof(BehaviorTree.RawNodes.Node[z]),24);
                            if (ID_offset != -1 && ID_offset % 2 == 0 && (ID_offset > startof(BehaviorTree.RawNodes.Node[z].Priority) || ID_offset < startof(BehaviorTree.RawNodes.Node[z].SelectorID))) {
                                FSeek(startof(BehaviorTree.RawNodes.Node[z]));
                                struct BHVTNode Node;
                            }
                        }
                        FSeek(startof(this)+1);
                    } Referencing_Nodes <size=1>;
            } else if (detectedHash(startof(data))) {
                struct {
                    for (h=0; h<BehaviorTree.NodeCount; h++) {
                        if (FindFirst(data,1,0,0,0.0,1,startof(BehaviorTree.RawNodes.Node[h]),sizeof(BehaviorTree.RawNodes.Node[h]),24) != -1) {
                            FSeek(startof(BehaviorTree.RawNodes.Node[h]));
                            struct BHVTNode Node;
                        }
                    }
                    if (FindFirst(data,1,0,0,0.0,1,RSZOffset,0,24) != startof(data) || FindFirst(data,1,0,0,0.0,1,FTell(),0,24) != -1) {
                        struct BHVTHash Same_Hash(id_All, "") <open=true>;
                        checkUseSpacers();
                    }
                    FSeek(startof(this)+4);
                } Same_Hash <name="Same Hashes", size=4>;
            }
            FSeek(pos);
        }


        if (elementSize > 16)
            FSeek(varStart + elementSize);
        else if (elementSize == 4 && exists(data) && startof(data)+4 <= FileSize() && ReadInt(startof(data)) <= 512)
            enums();
        
        if (!finished || (fieldType == Data_tid && !exists(ObjectIndex))) {
            local string OriginalType = fieldOrgTypeName;
            if (!finished) {
                FSkip(-1);
                ubyte FieldNamer <read=ReadVariableNamer, write=WriteVariableName>;
                lastVarEnd = FTell();
                if (ShowAlignment)
                    sizes[varIdx] = FTell()-startof(this);
            }
        }
    }
    
    if (title == "" && exists(this.size) && exists(this.data) && size > 1 ) {
        title = (wstring)data;
    } else if (title == "" && findS(fieldName, "ype") != -1) {
        title = ReadRSZVariable(this);
    } else if (secondTitle == "") {
        if (exists(this.UserData)) {
            secondTitle = ReadRSZMagic(this.UserData);
        } else if (exists(this.path.String)) {
            secondTitle = this.path.String;
        } else if (exists(this.Guid) && ReadUInt64(startof(Guid)) != 0) {
            secondTitle = ReadrGUID(Guid);
        } else if (exists(this.RSZ) && this.ObjectIndex > 2) {
            if (!isList || (exists(Count) && Count == 1)) {
                secondTitle = ReadRSZInstance(this.RSZ) + " ";
                if (secondTitle == " " || secondTitle == "False " || secondTitle == "True " || Atoi(secondTitle) != 0) 
                    secondTitle = "";
                else 
                    secondTitle = StrDel(secondTitle, sizeof(secondTitle)-1, 1);
            } else if (exists(parentof(this).var[0].RSZ) && parentof(this).Count > 1 && exists(parentof(this).var[parentof(this).Count-1])) {
                SPrintf(s, "%s - [%i]", ReadRSZInstanceName(parentof(this).var[0].RSZ), this.ObjectIndex) ;
                secondTitle = s;
            }
        }
    }
    
    if (exists(ResourceInfos) && exists(data) && (fieldType == String_tid || fieldDataType == "String") && find((wstring)data, "/") != -1 
    && FileNameGetExtension(data) != "" && FileNameGetExtension(data) != ".json") {
        local wstring fullPath <hidden=true>;
        ReadRSZPath((wstring)data);
        if (!finished && FindFirst( (wstring)data ) == startof(data) && exists(parentof(this).name) && parentof(this).name != "via.Folder" //detect filepaths that should be in ResourceInfos
        && (parentof(this).name != "via.Prefab" || (fieldIndex == 1 && parentof(this).var[0].data)) && detectedString(startof(data))) {
            SPrintf(ResourceInfos.noResourceInfoOutput, "%s\n%s", ResourceInfos.noResourceInfoOutput, data);
        }
    }
    if (FTell() <= startof(this)) {
        Printf("Empty field %i in %s at %i\n", fieldIndex, ReadRSZInstanceName(parentof(this)), startof(this)); 
        FSeek(startof(this));
    }
} RSZVariable <optimize=false, name=ReadRSZVariableName, read=ReadRSZVariable, write=WriteRSZVariable, comment=ReadRSZVariableComment>;

    string ReadRSZVariableComment(RSZVariable &r) { if (exists(r.data.GameObjectRef)) return r.data.GameObjectRef; return ""; }
    
    string ReadRSZVariableName(RSZVariable &r) { 
        local string s; 
        if (r.isList) {
            if ((exists(r.var[0]) && exists(r.var[0].ObjectIndex) && r.var[0].ObjectIndex != 0) || exists(r.var[0].UserData) ) {
                if (r.fieldDataType == "Data") {
                    SPrintf(s, "List (Object?) *%s", r.fieldName); // %s[%u] //, RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex].name, r.var[0].ObjectIndex
                } else { SPrintf(s, "List (%s) *%s", r.fieldDataType, r.fieldName); }
            } else if (exists(r.RSZ)) {
                s = ReadRSZInstanceName(r.RSZ);
                if (sizeof(s) + sizeof(r.fieldName) + 1 < 32 )
                    return s + " " + r.fieldName;
                return "List (Object) " + r.fieldName;
            } else 
                { s = "List" + " (" + r.fieldDataType + ") " + r.fieldName; }
        } else if (exists(r.ObjectIndex) && exists(parentof(r).fieldDataType) && parentof(r).fieldDataType == "List") {
            SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].name, r.ObjectIndex);
        } else if (r.fieldDataType != "") {
            if ((exists(r.RSZ) && r.ObjectIndex != 0) || exists(r.UserData) )
                s = r.fieldDataType + " *" + r.fieldName; 
            else if (r.fieldDataType + " " + r.fieldName == "Byte v0")
                s = "Byte v0 (isEnabled?)";
            else s = r.fieldDataType + " " + r.fieldName;  
        } else s = r.fieldName; 
        return s;
    }

    wstring ReadRSZVariable(RSZVariable &r) {
        local string s;
        if (exists(r.var)) {
            if (r.Count > 1 && exists(r.var[0].RSZ) && exists(r.var[r.Count])) {
                SPrintf(s, "%s - [%i]", ReadRSZInstanceName(r.var[0].RSZ), r.var[r.Count].ObjectIndex); 
                return s;
            } 
            return ReadRSZVariable(r.var[0]);
        } else 
            switch (r.fieldType) {
                case ukn_type:
                case Data_tid:
                    if (!exists(r.RSZ) && !exists(r.UserData) && exists(r.data)) {
                        if (r.elementSize == 1 ) { //|| r.fieldOrgTypeName == "Data1A1"
                            if (r.data == 1) {
                                s = "True";
                            } else if (r.data == 0) {
                                s = "False";
                            } else 
                                SPrintf(s, "%i", r.data);
                        } else if (r.elementSize == 4) {
                            if (r.data != 0 && detectedFloat(startof(r.data)))
                                SPrintf(s, "%f", ReadFloat(startof(r.data)));
                            else if (Abs(r.data) > 1000000) 
                                SPrintf(s, "%X", ReadInt(startof(r.data)));    
                            else 
                                SPrintf(s, "%i", ReadInt(startof(r.data)));
                        } else if (r.elementSize == 8) {
                            if (exists(r.data[1]) && (detectedFloat(FTell()) || detectedFloat(FTell()+4)))
                                SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                            else
                                SPrintf(s, "%Li", r.data);
                        } else if (r.elementSize == 16) {
                            if (exists(r.Guid))
                                s = ReadrGUID(r.Guid);
                            else if (exists(r.data[3]))
                                SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                        } else if (r.elementSize == 64) {
                            SPrintf(s, "[%g, %g, %g, %g] [%g, %g, %g, %g] [%g, %g, %g, %g] [%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], 
                                r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                        } else if (detectedFloat(startof(r)))
                            SPrintf(s, "%f", ReadFloat(startof(r.data)));
                        else SPrintf(s, "%f", ReadInt(startof(r.data)));
                        break;  //continue on to Object_tid if struct RSZ exists
                    }
                case Object_tid:
                case UserData_tid:
                    if (exists(r.RSZ))
                        return ReadRSZInstance(r.RSZ);
                    if (exists(r.UserData))
                        return ReadRSZMagic(r.UserData);
                    if (exists(r.path.String))
                        return r.path.String;
                    SPrintf(s, "%Li", ReadInt(startof(r)));
                    break;
                case Bool_tid:
                    if (exists(r.data))
                        s = ReadBOOL(r.data);
                    break;
		        case S8_tid:
		        case S16_tid:
		        case S32_tid:
		        case S64_tid:
		        case Size_tid:
                case U8_tid:
		        case U16_tid:
		        case U32_tid:
		        case U64_tid:
			    case Enum_tid:
                    if (exists(r.Enum))
                        SPrintf(s, "%s (%Li)", EnumToString(r.Enum), r.data);
                    else if (exists(r.data))
                        SPrintf(s, "%Li", r.data);
                    break;
                case F32_tid:
                    if (exists(r.data))
                        SPrintf(s, "%f", r.data);
                    break;
		        case Resource_tid:
                case String_tid:
                    if (exists(r.data))
                        return r.data;
                    break;
                case Float2_tid:
                case Vec2_tid:
                case Point_tid:
                case Range_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                    break;
                case Vec3_tid:
                case Float3_tid:
                case Int3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]", r.data[0], r.data[1], r.data[2]);
                    break;
                case Color_tid:
                case Vec4_tid:
                case Mat4_tid:
                case Float4_tid:
				case Quaternion_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.data))
                        s = ReadrGUID(r.data);
                    if (exists(r.Guid))
                        s = ReadrGUID(r.Guid);
                    break;
                case AABB_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g] [%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3],  r.data[4],  r.data[5],  r.data[6], r.data[7]);
                    break;
                case Mat4_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g] [%g, %g, %g, %g] [%g, %g, %g, %g] [%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    break;
                default:
                    break;
            }
        return s;
    }
    
    void FixRSZUserDataOffsets(uint insertPt, int addedSz, int secAddedSz, int lvl) {
        local ushort tempLvl, i, extraAddSize;
        while(exists(RSZFile[i])) {
            if (startof(RSZFile[lvl].RSZHeader) >= startof(RSZFile[i].RSZHeader) && startof(RSZFile[lvl]) 
                + sizeof(RSZFile[lvl]) <= startof(RSZFile[i]) + sizeof(RSZFile[i])) { //if RSZFile[lvl] is inside RSZFile[i]...
                extraAddSize = secAddedSz * (startof(RSZFile[lvl].RSZHeader) != startof(RSZFile[i].RSZHeader));
                if (exists(RSZFile[i].RSZUserDataInfos) && sizeof(RSZFile[i].RSZUserDataInfos) > 1) {
                    k=0; 
                    while(((!RTVersion && RSZVersion == "RE2") || RSZVersion == "DMC5") && exists(RSZFile[i].RSZUserDataInfos.userDataInfo[k])) {
                        tempLvl = getLevelRSZ(RSZFile[i].RSZUserDataInfos.userDataInfo[k].RSZOffset_Absolute.OffsetAbs);
                        if (exists(RSZFile[tempLvl].RSZHeader) && startof(RSZFile[lvl].InstanceInfos) > startof(RSZFile[tempLvl].RSZHeader) 
                        && startof(RSZFile[lvl].InstanceInfos) < startof(RSZFile[tempLvl]) + sizeof(RSZFile[tempLvl]))
                            RSZFile[i].RSZUserDataInfos.userDataInfo[k].dataSize += addedSz + extraAddSize;
                        k++;
                    }
                    if (startof(RSZFile[i].RSZHeader) < insertPt && RSZFile[i].RSZHeader.dataOffset_Absolute.offset > insertPt)
                        FixOffsets(startof(RSZFile[i].RSZUserDataInfos), startof(RSZFile[i].RSZUserDataInfos)+sizeof(RSZFile[i].RSZUserDataInfos)
                            , insertPt - startof(RSZFile[i].RSZHeader), FileSize()+addedSz, addedSz+extraAddSize, 0);
                    else
                        FixOffsets(startof(RSZFile[i].RSZUserDataInfos), startof(RSZFile[i].RSZUserDataInfos)+sizeof(RSZFile[i].RSZUserDataInfos)
                            , insertPt - startof(RSZFile[i].RSZHeader), FileSize()+addedSz, addedSz + extraAddSize, 0); // 
                }
                FixOffsets(startof(RSZFile[i].RSZHeader), startof(RSZFile[i].RSZHeader)+sizeof(RSZFile[i].RSZHeader)
                    , insertPt - startof(RSZFile[i].RSZHeader), FileSize()+addedSz, addedSz + extraAddSize , 0); // 
            }
            i++;
        }
    } 
    
    int getHeaderStringSize(uint stringStart) {
        local ushort g;
        while (headerStrings[g] != 0) {
            if (headerStrings[g] == stringStart)
                return headerStrings[g+1] - stringStart;
            g++;
        }
    }

    void WriteRSZString(RSZVariable &r, wstring s) { 
        local int oldDataSz, newPaddingSz;
        local uint oldFileSize = FileSize();
        local wstring str;
        
        if (exists(r.data)) 
            wstring oldData = r.data;
        else
            wstring oldData = "";
        
        if (s != " " && s[Strlen(s)-1] == 0x20)  //remove any random spaces from the end
            s[Strlen(s)-1] = 0;
        if (find(s, "\\\\") != -1) { //Formats a real filepath to RE Engine format
            if (find(s, "natives\\\\") != -1)
                s = WStrDel(s, 0, find(s, "natives\\\\") + 12);
            if (find(s, "[.]\\d") != -1)
                s = WStrDel(s, find(s, "[.]\\d"), sizeof(s) - find(s, "[.]\\d"));
            s = MakeBackslashes(s, true);
            WStrcpy(str,WStrDel(s, WStrlen(s), sizeof(s) - WStrlen(s)));
        } else 
            WStrcpy(str,s);
        
        if (exists(r.data)) {
            oldDataSz = sizeof(r.data);
            local int oldStringSz = sizeof(ReadWString(startof(r.data)));
            local int oldPaddingSz, rsInfoPadding, rsInfoStringSz, rsInfoStringStart;
            while (startof(r.data)+oldStringSz+oldPaddingSz < FileSize() && startof(r.data)+oldStringSz+oldPaddingSz < startof(r.data)+sizeof(r.data) 
            && ReadByte(startof(r.data)+oldStringSz+oldPaddingSz) == 0)
                oldPaddingSz++;
            if (sizeof(str) > sizeof(r.data))
                while((startof(r.data)+sizeof(str)+newPaddingSz) % 16 != (startof(r.data)+sizeof(r.data)) % 16)
                    newPaddingSz++;
            if (find(oldData, "/") != -1 && exists(Header.resourceCount))
                for (o=0; o<Header.resourceCount; o++) {
                    if (exists(ResourceInfos.ResourceInfo[o].pathStr) && ResourceInfos.ResourceInfo[o].pathStr.String == oldData) {
                        rsInfoStringStart = startof(ResourceInfos.ResourceInfo[o].pathStr.String);
                        rsInfoStringSz = getHeaderStringSize(rsInfoStringStart); break;
                    } else if (exists(ResourceInfos.ResourceInfo[o].path) && ResourceInfos.ResourceInfo[o].path == oldData) {
                        rsInfoStringStart = startof(ResourceInfos.ResourceInfo[o].path);
                        rsInfoStringSz = getHeaderStringSize(rsInfoStringStart); break;
                    }
                }
            
        } else {
            while((startof(r)+4+sizeof(str)+newPaddingSz) % 16 != (startof(r)+4) % 16)
                newPaddingSz++;
        }
        
        local int sizeToInsert = sizeof(str) - oldDataSz + newPaddingSz;
        
        //Printf("%i %i %i %i %i %i %i %i\n", rsInfoStringStart, rsInfoStringSz, sizeof(str), oldDataSz, oldPaddingSz, newPaddingSz, sizeof(str) - oldDataSz, sizeToInsert);
        if (sizeToInsert > 0) {
            if (BHVTStart != -1) {
                FixBHVTOffsets(sizeToInsert, startof(r)+4);
            } else {
                FixRCOLOffsets(sizeToInsert, startof(r)+4, FileSize()+sizeToInsert);
                if (exists(rsInfoStringSz) && rsInfoStringSz > 0 && rsInfoStringSz < sizeof(str))
                    while ((rsInfoStringStart + sizeof(str) + rsInfoPadding) % 16 != (rsInfoStringStart + rsInfoStringSz) % 16)
                        rsInfoPadding++;
                FixOffsets(0, headerStrings[0], startof(r.size)+4, FileSize()+sizeToInsert, sizeToInsert, false);
                FixRSZUserDataOffsets(startof(r.size)+4, sizeToInsert, 0, r.lvl); 
                if (exists(rsInfoPadding) && rsInfoPadding > 0) {
                    FixOffsets(0, startof(GameObjectInfos), startof(ResourceInfos) + sizeof(ResourceInfos), FileSize()+rsInfoPadding+(sizeof(str)-rsInfoStringSz), rsInfoPadding + (sizeof(str) - rsInfoStringSz), false);
                    FixOffsets(startof(GameObjectInfos)+sizeof(GameObjectInfos)-(sizeof(GameObjectInfos)==1), headerStrings[0], rsInfoStringStart+1, FileSize()+(sizeof(str)-rsInfoStringSz), (sizeof(str) - rsInfoStringSz), false); //rsInfoPadding +
                }
            }
            InsertBytes(startof(r.size)+4, sizeToInsert, 0); 
            r.size += sizeToInsert / 2;
        } else 
            sizeToInsert = 0;
        ForceWriteString(startof(r.size)+4, oldDataSz+sizeToInsert, str); 
        
        if (exists(rsInfoStringStart) && rsInfoStringStart > 0) {
            Printf("Found old ResourceInfo\n");//, rsInfoStringStart, rsInfoStringSz, rsInfoPadding); //Start = %i, Size = %i, Padding = %i\n
            if (rsInfoPadding > 0) 
                InsertBytes(RSZOffset, rsInfoPadding, 0);
            if (sizeof(str) > rsInfoStringSz)
                InsertBytes(rsInfoStringStart, sizeof(str) - rsInfoStringSz, 0);
            if (rsInfoStringSz > sizeof(str))
                ForceWriteString(rsInfoStringStart, rsInfoStringSz, str); 
            else
                ForceWriteString(rsInfoStringStart, sizeof(str), str);
            
        }

        if (oldFileSize != FileSize())
            ShowRefreshMessage("");
    }

    void WriteRSZVariable(RSZVariable &r, wstring s) {
        if (exists(r.fullPath) && r.fullPath != "" && s == " ") {
            FileOpener(r.fullPath);
        } else {
            local int pos = r.varStart;
            switch (r.fieldType) {
                case Bool_tid:
                    WriteBOOL(r.data, s); break;
		        case S16_tid:
                    WriteShort(pos, Atoi(s)); break;
		        case Object_tid:
		        case UserData_tid:
                    if (s == " " && exists(r.RSZ))
                        WriteRSZInstance(r.RSZ, s);
                    else if (s == " " && exists(r.path))
                        WriteStringRead(r.path, (string)s);
                    else
                        WriteInt(pos, Atoi(s)); 
                    break;
                case Size_tid:
		        case S32_tid:
                    WriteInt(pos, Atoi(s)); break;
		        case S64_tid:
                    WriteInt64(pos, Atoi(s)); break;
		        case S8_tid:
                    WriteByte(pos, Atoi(s)); break;
		        case U16_tid:
                    WriteUShort(pos, Atoi(s)); break;
		        case U32_tid:
                    WriteUInt(pos, Atoi(s)); break;
		        case U64_tid:
                    WriteUInt64(pos, Atoi(s)); break;
                case F32_tid:
                    WriteFloat(pos, Atof(s)); break;
                case String_tid:
                case Resource_tid:
                    WriteRSZString(r, s);
                    break;
                case Vec2_tid:
                case Range_tid:
                case Float2_tid:
                case Point_tid:
                    WriteRSZArray(r, s, 2, 4);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    WriteRSZArray(r, s, 3, 4);
                    break;
                case Vec4_tid:
                case Float4_tid:
                case Quaternion_tid:
                    WriteRSZArray(r, s, 4, 4);
                    break;
                case Color_tid:
                    WriteRSZArray(r, s, 4, 1);
                    break;
                case AABB_tid:
                    WriteRSZArray(r, s, 8, 4);
                    break;
                case Mat4_tid:
                    WriteRSZArray(r, s, 16, 4);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.data))
                        WriterGuid(r.data, (string)s);
                    else if (exists(r.Guid))
                        WriterGuid(r.Guid, (string)s);
                    break;
                case Data_tid:
                case ukn_type:
                    s = Lower(s);
                    if (exists(r.data) && r.elementSize == 1) {
                        if (s == "true") {
                            r.data = 1;
                        } else if (s == "false") {
                            r.data = 0;
                        } else r.data = Atoi(s);
                    } else if (exists(r.ObjectIndex) || exists(r.data_As_Int) || exists(r.data_As_Float)) {
                        if (exists(r.data_As_Int) || (exists(r.data) && r.data != 0 && detectedFloat(startof(r.data))) || find(s, "[.]") != -1) { 
                            WriteFloat(r.varStart, Atof(s));
                        } else {
                            WriteInt(r.varStart, Atoi(s));
                        }
                    } else if (exists(r.size) || find((wstring)r.fieldDataType, "tring") != -1) {
        	            WriteRSZString(r, s);
                    } else if (r.fieldDataType == "Vec4") {
                        WriteRSZArray(r, s, 4, 4);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    void WriteRSZArray(RSZVariable &r, wstring array, uint count, uint elementSize) {
        local uint q; 
        local float outArr[count];
        local string fmtString;
        local string FMT = "%g";
        if (elementSize == 1)
            FMT = "%i";
        if (array[0] == 91)
            fmtString += "[";
        if (find(array, ",") == -1) {
            for (q=0; q<count-1; q++)
                fmtString += FMT + " ";
            fmtString += FMT;
        } else {
            for (q=0; q<count-1; q++)
                fmtString += FMT + ", ";
            fmtString += FMT;
        }
        if (count == 2)
            SScanf(array, fmtString, r.data[0], r.data[1]);
        else if (count == 3)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2]);
        else if (count == 4)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2], r.data[3]);
        else if (count == 8)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7]);
        else if (count == 16)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10],  r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
    }

    string ReadVariableNamer(ubyte &v) { return "      [Input a Name or Datatype + Name to name this field]      "; }
    
    void WriteVariableName(ubyte &v, string newString) {
        local short fileNum = GetFileNum();
        local string locPath = FileNameGetPath(GetTemplateFileName());
        local string hashToFind; SPrintf(hashToFind, "%x", parentof(v).classHash);
        local string newFieldName = newString;
        local string newFieldType;
        if (findS(newString, " ") != -1) {
            newFieldType = SubStr(newString, 0, findS(newString, " "));
            newFieldName = SubStr(newString, findS(newString, " ")+1, -1);
            switch (newFieldType) {
                case "Byte": newFieldType = "S8"; break;
                case "UByte": newFieldType = "U8"; break;
                case "Int": newFieldType = "S32"; break;
                case "UInt": newFieldType = "U32"; break;
                case "Int64": newFieldType = "S64"; break;
                case "UInt64": newFieldType = "U64"; break;
                case "Float": newFieldType = "F32"; break;
                default: break;
            }
        }
        
        if (newFieldName == "")
            return;
        
        FileOpen(JsonPath);
        FileSelect(FindOpenFile(JsonPath));
        local int hashOffset = FindFirst(hashToFind, 0);
        local int varOffset = FindFirst(parentof(v).fieldName, 1, 0, 0, 0, 1, hashOffset, FindFirst("]", 1, 0, 0, 0, 1, hashOffset) - hashOffset);
        if (hashOffset > -1) {
            ReplaceAll(parentof(v).fieldName, newFieldName, 1, 1, 0, 0, 1, varOffset, sizeof(parentof(v).fieldName));
            if (!IsInitialized())
                ParseJson(JsonPath);
            if (newFieldType != "")
                ReplaceAll(GetFieldTypeName(parentof(v).classHash, parentof(v).fieldIndex), newFieldType, 1, 1, 0, 0, 1, varOffset, FindFirst("}", 1, 0, 0, 0, 1, varOffset) - varOffset); 
            SetCursorPos(varOffset);
            if (MessageBox( idOk | idCancel, "Change JSON", "Field will be changed to %s %s", newFieldType, newFieldName) == idOk) {
                FileSave();
                //FileClose();
                if (RSZVersion != "RE7" && MessageBox( idYes | idNo, "Change JSON", "Find and change this field in the other JSON dumps too?") == idYes) {
                    local string tempJSONPath;
                    for (j=0; j<5; j++) {
                        switch (j) {
                            case 0: tempJSONPath=Lower(locPath + "rszre2.json"); break;
                            case 1: tempJSONPath=Lower(locPath + "rszre3.json"); break;
                            case 2: tempJSONPath=Lower(locPath + "rszre8.json"); break;
                            case 3: tempJSONPath=Lower(locPath + "rszdmc5.json"); break;
                            default: tempJSONPath=Lower(locPath + "rszmhrise.json"); break;
                        }
                        if (tempJSONPath == JsonPath) 
                            continue;
                        FileOpen(tempJSONPath);
                        FileSelect(FindOpenFile(tempJSONPath));
                        hashOffset = FindFirst(hashToFind, 0);
                        varOffset = FindFirst(parentof(v).fieldName, 1, 0, 0, 0, 1, hashOffset, FindFirst("]", 1, 0, 0, 0, 1, hashOffset) - hashOffset);
                        if (varOffset > -1) {
                            ReplaceAll(parentof(v).fieldName, newFieldName, 1, 1, 0, 0, 1, varOffset, sizeof(parentof(v).fieldName));
                            if (newFieldType != "")
                                ReplaceAll(GetFieldTypeName(parentof(v).classHash, parentof(v).fieldIndex), newFieldType, 1, 1, 0, 0, 1, varOffset, FindFirst("}", 1, 0, 0, 0, 1, varOffset) - varOffset); 
                            SetCursorPos(varOffset);
                            if (MessageBox( idOk | idCancel, "Change JSON", "Field will be changed to %s %s", newFieldType, newFieldName) == idOk)
                                FileSave();
                            //FileClose();
                        } else {
                            Printf("Field '%s' not found in %s\n", parentof(v).fieldName, tempJSONPath);
                            //FileClose();
                        }
                    }
                }
            }
        } else {
            Printf("Field '%s' not found in %s!\n", parentof(v).fieldName, JsonPath);
            //FileClose();
        }
        FileSelect(fileNum);
    }

typedef struct {
    //find out if on-demand:
    local ubyte isOnDemand <hidden=true> = (sizeof(this) != 0) || (sizeof(parentof(this)) != 0);
    
    //Get containing RSZMagic index:
    if (exists(parentof(this).lvl))  
        local ushort lvl <hidden=true> = parentof(this).lvl;
    else 
        local ushort lvl <hidden=true> = getLevel(FTell());
    if (finished && BHVTStart != -1 && startof(parentof(this)) < RSZOffset)
        local string RSZLevel = ReadRSZMagicName(RSZFile[lvl]);
    
    //Get Instance index:
    local int idx <hidden=true>;
    if (isOnDemand && exists(ObjectIndex)) {
        idx = ObjectIndex;
    } else if (exists(RSZIdx)) {
        idx = RSZIdx;
    } else {
        idx = i;
    }

    if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) ) { //|| GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF
        if (!noRetry) {
            ParseJson(JsonPath);  Printf("\nParsing JSON %s\n", JsonPath);
            if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) )
                noRetry = TRUE;
        }
    }
    
    
    local string name <hidden=true> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.HashName;
    local wstring title <hidden=true>; 
    local wstring secondTitle <hidden=true>;
    local uint hash <hidden=true, format=hex> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash;
    local ubyte isUserData <hidden=true>;
    local ushort fieldCount <hidden=true> = GetFieldCount(hash);
    
    if (exists(RSZFile[lvl].RSZUserDataInfos) && sizeof(RSZFile[lvl].RSZUserDataInfos) != 1)
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].typeId.Hash == hash) 
                { isUserData = TRUE; break; }

    if (name == "Unknown Class!"){
        Printf("Hash %X not found in JSON %s\n", hash, RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.HashName);
        byte skip <hidden=true>;
    } else if (idx && GetFieldCount(hash) == 0xFFFFFFFF) { 
        Printf("Class %u %s not detected in JSON!\n", hash, name);
        byte skip <hidden=true>;
    } else if (isUserData) {
        if (FEof()) 
            FSkip(-1);
        byte skipFileData <hidden=true>;
        local short userDataIdx <hidden=false> = -1;
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == RSZ.idx) { 
                userDataIdx = j;
                if ((!(RSZVersion == "RE2" && !RTVersion) && RSZVersion != "DMC5")) {
                    local wstring userDataPath <hidden=true> = RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String; 
                    local wstring fullPath <hidden=true>;
                    ReadRSZPath(userDataPath);
                    if (title == "")
                        title = userDataPath;
                }
                break; 
            }
    } else if (idx && !FEof()) {
        local int z <hidden=true>, FieldType <hidden=true>, FieldSize <hidden=true>, IsList <hidden=true>;
        for (z = 0; z < GetFieldCount(hash); z++) {
            FieldType = (TypeIDs)GetFieldType(hash, z);
            FieldSize = GetFieldSize(hash, z);
            IsList = GetFieldArrayState(hash, z);
            if (IsList)
                FSeek(getAlignedOffset(FTell(), 4));
            else
                FSeek(getAlignedOffset(FTell(), GetFieldAlignment(hash, z)));   
            
            //Detect and set colors:
            if (FieldType == Color_tid && !IsList) {
                //local ubyte B = (int)ReadUByte(FTell()+2)<<16, G = (int)ReadUByte(FTell()+1)<<8, R = (int)ReadUByte(FTell());
                temp = ((int)ReadUByte(FTell()+2)<<16 | (int)ReadUByte(FTell()+1)<<8 | (int)ReadUByte(FTell()));
                SetForeColor(temp); 
                SetBackColor(temp);
            } else if ((FieldSize == 16 && GetFieldAlignment(hash,z) == 16 && detectedColorVector(FTell())) && (findS(this.name, "olor") != -1 
            || findS(GetFieldName(hash,z), "olor") != -1 || (FieldType == Data_tid && findS(this.name, "render") != -1)) )  {
                temp = ( (int)readColorFloat(FTell()+8)<<16 | (int)readColorFloat(FTell()+4)<<8 | (int)readColorFloat(FTell()));
                SetForeColor(temp); 
                SetBackColor(temp);
            } else (!broken ) ? SetForeColor(cGreen) : SetForeColor(cYellow); // bed 3045
            
            if (FTell() + 4 <= FileSize() && ReadUInt(FTell()) != 0 && FieldType == Object_tid || FieldType == UserData_tid || FieldType == ukn_type 
            || (FieldType == Data_tid && FieldSize == 4 && FTell() + 4 + (IsList * 4) <= FileSize() && detectedObject(FTell() + (IsList * 4)))) {
                struct RSZVariable var(hash, z);
            } else {
                struct RSZVariable var(hash, z) <open=suppress>;
            }
            SetForeColor(cNone);
            SetBackColor(cNone);
        }
    } 
    if (!finished && FEof())
        i = RSZHeader.instanceCount; 
    
    if (title == "") {
        if (secondTitle != "") {
            title = secondTitle;
        } else if (exists(this.var[0])) {
            if (exists(this.var[0].RSZ)) {
                title = ReadRSZInstanceName(this.var[0].RSZ);
            } else {
                title = ReadRSZVariable(this.var[0]);
            }
        }
    }
    if (FTell() - startof(this)  == 0) { 
        if (FEof())
            FSkip(-1);
        ubyte skipFileData <hidden=true>;
    }
    if (FTell()==startof(this))
        Printf(name + "\n");
} RSZInstance <name=ReadRSZInstanceName, read=ReadRSZInstance, write=WriteRSZInstance>;

    wstring ReadRSZInstanceName(RSZInstance &r) { 
        local ushort lvl <hidden=true>;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        local string s;
        
        if (exists(r.idx)) {
            if (exists(r.skip) || exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))
                s = "*";
            if (exists(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx]))
                s += RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.HashName;
            else if (exists(r.name))
                s += r.name;
            if (!exists(parentof(r).temp))
                SPrintf(s, "%s[%u]", s, r.idx);
        } else if (exists(RSZFile[lvl].RSZHeader)) {
            local uint idx;
            for (idx=getRSZWaypointIndex(startof(r), lvl);idx<RSZFile[lvl].RSZHeader.instanceCount;idx++) {
                if (exists(RSZFile[lvl].Data.RawData.RSZ[idx]) && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skipFileData) 
                && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skip) && startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(r)) { 
                    SPrintf(s, "%s[%u]", ReadRSZInstanceName(RSZFile[lvl].Data.RawData.RSZ[idx]), idx);
                    break;
                }
            }
        }
        return s;
    }

    int SizeRSZInstance(RSZInstance &r) { 
        local ushort idx;
        if (exists(parentof(r).lvl))
            local ushort lvl = parentof(r).lvl;
        else
            local ushort lvl = getLevel(startof(r));
        
        if ((exists(varStart) && exists(RSZFile[lvl].Data.RawData.RSZ[ReadUInt(varStart)]))) //detectedObject(varStart)
            return sizeof(RSZFile[lvl].Data.RawData.RSZ[ReadUInt(varStart)]); 
        for (idx=getRSZWaypointIndex(startof(r), lvl);idx<RSZFile[lvl].RSZHeader.instanceCount;idx++) 
            if (startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skipFileData))
                return sizeof(RSZFile[lvl].Data.RawData.RSZ[idx]);
        return 4;
    }

    int getRSZWaypointIndex(uint32 tell, ushort lvl) { 
        local short div = RSZFile[lvl].Data.RawData.divCounter-1;
        while (tell < RSZFile[lvl].Data.RawData.waypoints[div / 2])
            div = div / 2;
        for (div; div>0; div--)
            if (tell >= RSZFile[lvl].Data.RawData.waypoints[div])
                return (int)(div * 100);
        return 1;
    }

    wstring ReadRSZInstance(RSZInstance &r) {
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else 
            lvl = getLevel(startof(r));
        if (exists(r.skip)) {
            return ReadHash(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.Hash);
        } else if (exists(r.skipFileData) && exists(RSZFile[lvl].RSZUserDataInfos)) {
            for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
                if (exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[j]) && RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == r.idx)
                    return RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String;
        } else if (exists(r.title)) {
            return r.title;
        } else if (exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex])) {
            return ReadRSZInstance(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex]);
        } else {
            local ushort idx;
            for (idx=getRSZWaypointIndex(startof(r), lvl);idx<RSZFile[lvl].RSZHeader.instanceCount;idx++) 
                if (startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skipFileData))
                    return RSZFile[lvl].Data.RawData.RSZ[idx].title;
        } return "";
    }

    void WriteRSZInstance(RSZInstance &r, wstring s) { 
        if (exists(r.fullPath) && s == " ")
            FileOpener(r.title);
        else {
            local int w;
            local string oldVar = ReadRSZInstance(r);
            while(exists(r.var[w])) {
                if (ReadRSZVariable(r.var[w]) == oldVar) {
                    WriteRSZVariable(r.var[w], s);
                    r.title = ReadRSZVariable(r.var[w]);
                    break;   
                }
                w++;
            }
        }
    }

//================= 
//Other typedefs:

typedef struct(int64 atAddress, int64 addOffset, byte isAbsolute) {
    if (isAbsolute < 1) {
        if (atAddress > -1)
            FSeek(atAddress); 
        if (isAbsolute == 0) {
            uint64 strOffset;
            FSeek(strOffset + addOffset);
        } else { //for BHVTNodes
            uint strOffset;
            if (BHVTStart != -1)
                FSeek((strOffset * 2) + addOffset);
            else FSeek(strOffset);
        }
    } else
        FSeek(atAddress + addOffset);
    if (atAddress == -2)
        string String <open=suppress>;
    else
        wstring String <open=suppress>;
    
    if (find((wstring)String, "/") != -1 && FileNameGetExtension(String) != ".json") {
        if (startof(this)<RSZOffset) {
            headerStrings[headerStringsCount] = startof(String);
            headerStringsCount += 1;
        }
        local wstring _String <hidden=true> = String;
        local wstring fullPath <open=suppress, hidden=true>;
        ReadRSZPath(String);
    }
    if (exists(strOffset)) {
        if (atAddress < 0 || startof(this) == atAddress) {
            FSeek(startof(strOffset)+4+((isAbsolute != -1)*4));
        } else 
            FSeek(startof(this)+1);
    }
    if (FTell() - startof(this) == 0)
        Printf("%i\n", startof(parentof(this)));
} StringRead <open=suppress, read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) { return st.String; }
    
    void WriteStringRead(StringRead &st, string s) { 
        if (s == " " && exists(st.fullPath) && st.fullPath != "")
            FileOpener(st.fullPath);
        else {
            char buffer[sizeof(st.String)];
            WriteBytes(buffer, startof(st.String), sizeof(st.String)); //write 0s
            st.String = s; 
        }
    }
    
    string ReadPreFabName(struct PreFab &b) {
        if (exists(p.id.OpenFile))
            return "Prefab (Exists)";
        return "Prefab";
    }

typedef struct {
	uint32 Hash;
	local string HashName = ReadHashName(Hash);
} HASH <read=ReadHASH>;

    string ReadHASH (HASH &h) {
	    return ReadHash(h.Hash);
    }
    
    string ReadHash(uint32 &input) {
	    string s;
	    SPrintf(s, "%X", input);
	    return s;
    }
    
    string ReadHashName(uint32 &input) {
        if (!IsInitialized())
            ParseJson(JsonPath);
        return GetRSZClassName(input);
    }

    string ReadHASHWithName(HASH &h) {
        return ReadHash(h.Hash) + " -- " +  GetRSZClassName(h.Hash);
    }

typedef struct {
    wstring str;
} WSTRING <optimize=false, read=ReadWSTRING, write=WriteWSTRING>;
    wstring ReadWSTRING(WSTRING &input) { return input.str; }
    void WriteWSTRING(WSTRING &input, wstring s) {
        for (k = 0; k < sizeof(input.str)/2; k++)
            input.str[k] = 0;
        input.str = s;
    }

typedef struct {
    uint32 nameHash <format=hex>;
    uint32 type;
    //local wstring hashName <hidden=true>;
    switch (type) {
        case 6:  //CallbackNode
            uint32 value; 
            break;
        case 7:  //LogicNode
            uint32 value; 
            break;
        case 20: //VariableReferenceNode
            uint64 hashOffs; 
            break;
        default:
            if (ReadUInt64(FTell()) > 0 && ReadUInt64(FTell()) <= FileSize()-16 && ReadUInt64(FTell()) > FTell()) {
                uint64 hashOffs; 
            } else if (detectedFloat(FTell())) {
                float value;
            } else {
                uint value;
            }
            break;
    }
    if (exists(value) && detectedHash(startof(value)))
        local wstring RSZClass <hidden=true> = GetRSZClassName(value);
    
    if (exists(hashOffs)) {
        FSeek(UVARStart + hashOffs);
        rGUID value;
    }
    FSeek(startof(nameHash) + 16);
} UVAR_VALUE <read=ReadUVAR_VALUE, optimize=false>;

    string ReadUVAR_VALUE (UVAR_VALUE &input) {
        string s;
        if (exists(input.value))
            if (exists(input.RSZClass))
                return input.RSZClass;
            else if (sizeof(input.value)==16)
                return ReadrGUID(input.value);
            else if (detectedFloat(startof(input.value)))
                SPrintf(s, "%g", input.value);
            else 
                SPrintf(s, "%u", input.value);
        return s;
    }

typedef struct {
    ushort propCount, B, C;
    skipToNextLine();
    uint64 offs1, offs2;
    if (propCount > 0) {
        if (offs1 <= FileSize()) {
            FSeek(UVARStart + offs1);
            string name;
        }
        if (offs2 <= FileSize()) {
            FSeek(UVARStart + offs2);
            if (ReadUShort(FTell()+2) != 0)
                UVAR_VALUE Value;
        }
    }
    FSeek(startof(this)+32);
} SUBPROP2 <optimize=false>;

typedef struct {
    if (finished)
        if (ReadUInt64()+BHVTStart < FTell())
            UVARStart = FindFirst("uvar",1,0,0,0.0,0,0,0,24) - 4;
        else
            UVARStart = BHVTStart;
    struct StringRead name(-2, UVARStart, false);
    uint64 dataOffset;
    FSkip(8);
    ushort uknCount;
    ushort valueCount;
    ushort uknCount;
    ushort uknCount;
    FSeek(UVARStart + dataOffset);
    if (dataOffset > 0 && dataOffset + UVARStart <= FileSize())
        for (k=0; k<valueCount; k++) {
            UVAR_VALUE Value;
        }
    
    if (exists(Value.value)) {
        if (sizeof(Value.value)==16 && name.String == "VariableReferenceNode") {
            struct {
                local int tester <hidden=true> = ReadInt(startof(Value.value));
                local int RSZIdx <hidden=true>;
                local int tt <hidden=true>, rr <hidden=true>, vv <hidden=true>, doExit <hidden=true>;
                while (exists(RSZFile[tt])) {
                    rr=0;
                    while (exists(RSZFile[tt].Data.RawData.RSZ[rr])) {
                        vv=0;
                        while (exists(RSZFile[tt].Data.RawData.RSZ[rr].var[vv])) {
                            if (ReadInt(startof(RSZFile[tt].Data.RawData.RSZ[rr].var[vv])) == tester) {
                                FSeek(startof(RSZFile[tt].Data.RawData.RSZ[rr]));
                                RSZIdx = rr;
                                struct RSZInstance RSZ; 
                                FSeek(startof(this)+4);  
                            }
                            vv++;
                        }
                        rr++;
                    }
                    tt++;
                }
            } VariableRef <size=4>;
            FSkip(-4);
        }
    }
    FSeek(startof(this)+32);
} UVAR_NODE <name=ReadUVAR_NODENAME, read=ReadUVAR_NODE, optimize=false>;

    string ReadUVAR_NODENAME (UVAR_NODE &input) { if (exists(input.name.String)) return input.name.String; return ""; }

    string ReadUVAR_NODE (UVAR_NODE &input) { if (exists(input.Value)) return ReadUVAR_VALUE(input.Value[0]); return ""; }

typedef struct {
    ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
} OFFSET2_DATA;

typedef struct {
    uint64 nodesOffset;
    uint64 offset2;
    ushort propCount, ukn00, ukn01; //skipToNextLine();
    if (propCount > 0) {
        if (nodesOffset > 0) {
            FSeek(UVARStart + nodesOffset);
            if (FTell()+4 <= FileSize() && ReadUInt(FTell()) <= FileSize())
                struct UVAR_NODE Node[propCount];
            else 
                string name <open=suppress>;
        }
        if (offset2 > 0 && UVARStart + offset2 + 16 <= FileSize()) {
            FSeek(UVARStart + offset2);
            struct OFFSET2_DATA Unknown;
            while (FTell()+8 <= FileSize() && (ReadUInt64(FTell()) > FileSize() || ReadUInt64(FTell()+8) > FileSize()) && ReadByte(FTell()+2) == 0)
                struct OFFSET2_DATA Unknown;
        }
    }
    checkUseSpacers();
    if (FTell() < startof(this))
        FSeek(startof(this));
} UVAR_PROP <read=ReadUVAR_PROP, optimize=false>;  
    
    string ReadUVAR_PROP (UVAR_PROP &input) {
        if (exists(input.name))
            return input.name;
        if (exists(input.Node))
            return ReadUVAR_NODE(input.Node[0]);
        return "";
    }

typedef struct {
    rGUID Guid;
    if (ReadUInt64() + BHVTStart < FTell())
        UVARStart = FindFirst("uvar",1,0,0,0.0,0,0,0,24) - 4;
    else
        UVARStart = BHVTStart;
    
    struct StringRead name(-1, UVARStart, false);
    uint64 floatOffset, propOffset;
    uint type : 24;
    uint numBits : 8;
    uint nameHash;
    
    if (floatOffset > 0) {
        FSeek(UVARStart + floatOffset);
        if ((numBits / 32) <= 1) {
            float Value_As_Float;
            FSkip(-4);
            int Value_As_Int;
        } else {
            float Value_As_Float[(numBits / 32)];
            FSkip(-4);
            int Value_As_Int[(numBits / 32)];
        }
    }
    
    //local int test = BHVTStart;
    
    if (propOffset > 0) {
        FSeek(UVARStart + propOffset);
        struct UVAR_PROP VarData;  
        if (exists(furthestExtent) && FTell() > furthestExtent)
            furthestExtent = FTell();
    }
    FSeek(startof(nameHash) + 4);
} UVARIABLE <optimize=false, name=ReadUVariableName, read=ReadUVariable, write=WriteUVariable>;

    wstring ReadUVariableName(UVARIABLE &input) { if (exists(input.VarData)) return ("*"+input.name.String); return input.name.String; }

    void WriteUVariable(UVARIABLE &input, string s) { if (detectedFloat()) WriteFloat(startof(input.Value_As_Int), Atoi(s)); else WriteUInt(startof(input.Value_As_Int), Atoi(s)); }

    wstring ReadUVariable(UVARIABLE &input) {
        string s = "";
        if (exists(input.Value_As_Float)) {
            if (detectedFloat(startof(input.Value_As_Float)))
                SPrintf(s, "%g", input.Value_As_Float[0]);
            else
                SPrintf(s, "%u", input.Value_As_Int[0]); 
        }
        return (s);
    }

typedef struct {
    struct {
        uint version;
        uint magic;
        uint64 stringsOffset;
        uint64 dataOffset;
        uint64 embedsInfoOffset;
        uint64 hashInfoOffset;
        uint64 ukn;
        uint UVARhash;
        ushort variableCount;
        ushort embedCount;
    } header;
    local uint variableCount = header.variableCount;
    if (header.magic == id_uvar) {
        local uint UVARStart <hidden=true> = BHVTStart;
        if (header.dataOffset + BHVTStart < startof(this) + 56)
            UVARStart = startof(this); 
        
        if (header.variableCount && header.dataOffset+this.UVARStart > startof(this)) { 
            local int furthestExtent <hidden=true>;
            FSeek(this.UVARStart + header.dataOffset);
            struct {
                for (j=0;j<header.variableCount;j++) 
                    struct UVARIABLE Var;
            } Data;
        }
        if (header.stringsOffset) { 
            FSeek(this.UVARStart + header.stringsOffset);
            struct {
                if (header.variableCount)
                    WSTRING str[header.variableCount] <open=suppress>;
                else while (detectedString(FTell()))
                    WSTRING str <open=suppress>;
            } Strings;
        }
        if (header.dataOffset + BHVTStart < startof(this) + 56)
            this.UVARStart = startof(this); 
        
        if (header.variableCount ) { //&& header.hashInfoOffset+this.UVARStart > startof(this)
            if (this.UVARStart + header.hashInfoOffset > FileSize())
                this.UVARStart = BHVTStart; 
            FSeek(this.UVARStart + header.hashInfoOffset);
            struct {
                uint64 HashDataOffsets[4];
                FSeek(parentof(this).UVARStart + HashDataOffsets[0]);
                struct {
                    struct rGUID GUIDs[header.variableCount] <optimize=false>;
                } GUIDs;
                FSeek(parentof(this).UVARStart + HashDataOffsets[1]);
                uint dataHashMap[header.variableCount];
                FSeek(parentof(this).UVARStart + HashDataOffsets[2]);
                uint nameHashes[header.variableCount];
                FSeek(parentof(this).UVARStart + HashDataOffsets[3]);
                uint nameHashMap[header.variableCount];
            } HashData;
            
            if (FTell() + 4 <= FileSize() && ReadInt() > 0 && ReadInt() < 128 && ReadUInt64(FTell()+4)+this.UVARStart > FTell() && ReadUInt64(FTell()+4)+this.UVARStart < FileSize())
                struct {
                    uint embedCount;
                    uint64 embedOffsets[embedCount];
                    for (i=0; i<embedCount; i++) {
                        FSeek(parentof(this).UVARStart + embedOffsets[i]);
                        struct UVAR UVAR_File;
                    }
                    FSeek(startof(embedOffsets)+embedCount*8);
                } EmbeddedUVARs;            
        }
        if (header.variableCount == 0) {
            FSeek(getAlignedOffset(FTell(),16));
            struct {
                uint64 NextOffset, NextOffset, NextOffset, NextOffset;
            } EndOffsets;
        }
    }
} UVAR <read=ReadUVAR>;

    wstring ReadUVAR (UVAR &input) {
        if (exists(input.Data.Var[0]))
            return input.Data.Var[0].name.String;
        return "";
    }

struct OBJECTID(int lv) {
    int id;
    local int level <hidden=true> = lv;
};

typedef OBJECTID ObjectId <read=ReadObjectIdTitle, write=WriteObjectId>;

    wstring ReadObjectIdName(ObjectId &o) {
        local string s;
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) && exists(RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]])) {
            SPrintf(s, "%i -- %s", o.id, RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]].typeId.HashName);
            if (s != "")
                SPrintf(s, "%s[%i]", s, RSZFile[o.level].ObjectTable[o.id]);
        }
        return s;
    }

    wstring ReadObjectId(ObjectId &o) {
        local string s;
        SPrintf(s, "%i", o.id);
        return s;
    }

    void WriteObjectId(ObjectId &o, string s) {
        o.id = Atoi(s);
    } 

    wstring ReadObjectIdTitle(ObjectId &o) {
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) 
        && exists(RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]])) {
            local string s = ReadObjectId(o) + " -- " + RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]].title;
            return s;
        }
        return "";
    }

    wstring ReadInstanceID(ObjectId &in) { 
        if (exists (RSZFile[in.level].InstanceInfos.instanceInfo[in.id].typeId.HashName)) {
            local string s; 
            SPrintf(s, "%i -- %s", in.id, RSZFile[in.level].InstanceInfos.instanceInfo[in.id].typeId.HashName);
            return s; 
        } 
        return ""; 
    }

    string readUknPFBInfoShort (ushort &u) {  string s;  SPrintf(s, "%i (%s)", u, ReadGRefInfo(GameObjectInfos.GameObjectInfo[u]));  return s ; }

struct fakeGameObject {
    FSeek(getAlignedOffset(FTell(), 4));
    uint size0;
    if (size0 && FTell()+size0*2 <= FileSize())
        wchar_t name[size0];
    FSeek(getAlignedOffset(FTell(), 4));
    uint size1;
    if (size1 && FTell()+size1*2 <= FileSize())
        wchar_t tag[size1];
    FSeek(getAlignedOffset(FTell()+2, 4));

    uint timeScale;
};

typedef struct(int structType, uint64 addOffset) {
    uint64 offset;
    FSeek(offset + addOffset);
    switch (structType) {
        case 0: struct RSZMagic RSZ <size=56>; break;
        case 1: struct RSZInstance RSZ <size=4>; break;
        default: break;
    }
    if (structType == 0 && ReadUInt(startof(RSZ)) != 5919570)
        Printf("RSZMagic not found at RSZ[%i] in BHVT header\n", getLevelRSZ(startof(RSZ)));
    //checkUseSpacers();
    FSeek(startof(offset)+8);
} ReadStruct;// <read=ReadReadStruct, write=WriteReadStruct, size=8>;

    //string ReadReadStruct(ReadStruct &r) { local string s; SPrintf(s, "%i", r.offset); return s; }
    
    //void WriteReadStruct(ReadStruct &r, string s) { r.offset = Atoi(s); }
    
void fakeStateList() {
    local int count = ReadInt(); 
    FSkip(4);
    if (count && FTell() + count * 4 < FileSize()) {
        FSkip(count * 4);
    }
}

//Murmur3 hash generation by Darkness:
uint32 fmix32(uint32 h){
    h ^= h >> 16;
    h *= 0x85ebca6b;
    h ^= h >> 13;
    h *= 0xc2b2ae35;
    h ^= h >> 16;
    return h;
}

uint32 mmh3 (byte key[], uint32 length , uint32 seed){
    local uint64 block_start<hidden=true>;
    local const uint nBlocks = length / 4;
    local uint32 h1 = seed;
    
    local const uint32 c1 = 0xcc9e2d51;
    local const uint32 c2 = 0x1b873593;

    local uint32 k1;
    for(block_start = 0; block_start < nBlocks * 4; block_start+= 4){
        k1 = (uint32)key[block_start + 3] << 24 | \
             (uint32)key[block_start + 2] << 16 | \
             (uint32)key[block_start + 1] << 8 | \
             (uint32)key[block_start + 0];

        k1 = (c1 * k1) & 0xFFFFFFFF;
        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF;
        k1 = (c2 * k1) & 0xFFFFFFFF;

        h1 ^= k1;
        h1 = (h1 << 13 | h1 >> 19) & 0xFFFFFFFF;
        h1 = (h1 * 5 + 0xe6546b64) & 0xFFFFFFFF;
    }

    local uint32 tail_index = nBlocks * 4;
    k1 = 0;
    local uint32 tail_size = length & 3;

    if(tail_size >= 3)
        k1 ^= (uint32)key[tail_index + 2] << 16;
    if(tail_size >= 2)
        k1 ^= (uint32)key[tail_index + 1] << 8;
    if(tail_size >= 1)
        k1 ^= (uint32)key[tail_index + 0];

    if(tail_size > 0){
        k1 = (k1 * c1) & 0xFFFFFFFF;
        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF;
        k1 = (k1 * c2) & 0xFFFFFFFF;
        h1 ^= k1;
    }

    return fmix32(h1 ^ length);
}

uint32 hash_wide(string key){
    local uint64 it<hidden=true>;
    local const uint length = Strlen(key) * 2;
    if (length) {
        local byte key_array[length];
        for(it = 0; it < length; it += 2){
            key_array[it] = key[it / 2];
            key_array[it + 1] = 0;
        }
        return mmh3(key_array, length, 0xFFFFFFFF);
    } return 0;
}

typedef struct {
    ubyte dummy <hidden=true>;
    local string String_Form = "";
    local int Hash_Form;
    local uint Hash_Form_unsigned;
} HashGenerator <read=ReadStringToHash, write=WriteStringToHash>;
    
    string ReadStringToHash(HashGenerator &h) { 
        if (h.Hash_Form )  {
            local string ss; SPrintf(ss, "%i (%u) = %s", h.Hash_Form, h.Hash_Form_unsigned, h.String_Form);
            return ss;
        } return "      [Input a String here to turn it into a Murmur3 Hash]"; 
    }
    
    void WriteStringToHash(HashGenerator &h, string s) {
        h.String_Form = s;
        h.Hash_Form = hash_wide(h.String_Form);
        h.Hash_Form_unsigned = hash_wide(h.String_Form);
    }

    string readRCOLWarning (uint &u) { 
        string s; SPrintf(s,"%i",u);
        if (sizeof(RSZFile[0]) != u) 
            SPrintf(s, "%s -- Warning: Size does not match real size (%i)", s, sizeof(RSZFile[0]));
        return s;
    }

typedef enum {
    id_SCN = 5129043,
    id_PFB = 4343376,
    id_USR = 5395285,
    id_RCOL = 1280262994,
    id_mfs2 = 846423661,
    id_BHVT = 1414940738,
    id_uvar = 1918989941
} MAGIC;


//Start of reading File =====================================================================================================================================
FSeek(0);
if (ReadUInt(0)==id_SCN || ReadUInt(0)==id_PFB || ReadUInt(0)==id_USR || ReadUInt(0)==id_RCOL || ReadUInt(4)==id_mfs2 || ReadUInt(0)==id_BHVT )
    struct {
        HashGenerator HashMaker <name="Hash Generator">;
        FSkip(-1);
        
        local MAGIC magic <hidden=true> = ReadUInt(FTell());
        if (ReadUShort(2) == 0)
            magic = ReadUInt(FTell()+4);
	    if (magic == id_BHVT)
            MAGIC magic;
        
        isAIFile = (findS(filename, "bhvt") != -1);
        
        if (magic == id_PFB) {
            MAGIC signature;
	        int infoCount;
            int resourceCount;
            
            if (RSZVersion != "DMC5" && !(RSZVersion == "RE2" && !RTVersion)) {
                int uknPFBInfoCount;
                if (RSZVersion != "RE7" || RTVersion) {
                    int userdataCount;
                    int reserved;
                }
                uint64 uknPFBInfoTbl;
	            uint64 resourceInfoTbl;
                if (RSZVersion != "RE7" || RTVersion)
	                uint64 userdataInfoTbl;
            } else {
                int uknPFBInfoCount;
	            uint64 uknPFBInfoTbl;
	            uint64 resourceInfoTbl;
            }
	        uint64 dataOffset;
        }
    
        if (magic == id_USR) {
            MAGIC signature;
            int resourceCount;
            int userdataCount;
            int InfoCount;
	        uint64 resourceInfoTbl;
	        uint64 userdataInfoTbl;
	        uint64 dataOffset;
        }

        if (magic == id_RCOL) {
            MAGIC signature;
            int numGroups;
            int numShapes;
            int numUserData;
            int numRequestSets;
            uint maxRequestSetId;
            //if (RSZVersion == "RE8" || RSZVersion == "MHRise" || (RTVersion && RSZVersion != "DMC5")) {
            if (!(RSZVersion == "DMC5" || (!RTVersion && (RSZVersion == "RE2" || RSZVersion == "RE7")))) {
                int numIgnoreTags;
                int numAutoGenerateJoints;
            }
            uint userDataSize <read=readRCOLWarning>;
            uint status;
            if (!RTVersion && RSZVersion == "RE3") {
                uint64 uknA; 
                uint64 uknB; 
            }
            if (RTVersion && RSZVersion == "RE7")
                uint64 uknA;
            uint64 groupsPtrTbl;
            uint64 dataOffset <name="userDataStreamPtr">;
            uint64 requestSetTbl; 
            //if (RSZVersion == "RE8" || RSZVersion == "MHRise"  || (RTVersion && RSZVersion != "DMC5")) {
            if (!(RSZVersion == "DMC5" || (!RTVersion && (RSZVersion == "RE2" || RSZVersion == "RE7")))) {
                uint64 ignoreTagTbl;
                uint64 autoGenerateJointDescTbl;
            }
        }
        if (magic == id_SCN) {
            MAGIC signature;
            int infoCount;
            int resourceCount;
            int folderCount;
            if (RSZVersion == "DMC5" || (!RTVersion && (RSZVersion == "RE2" || RSZVersion == "RE7"))) {
                int userdataCount;
                int prefabCount;
            } else {
                int prefabCount;
                int userdataCount;
            }
    
            uint64 folderInfoTbl;
            uint64 resourceInfoTbl;
            uint64 prefabInfoTbl;
            if (RSZVersion != "RE7" || RTVersion) 
                uint64 userdataInfoTbl;
            uint64 dataOffset;
        }

        if (exists(dataOffset) && ReadUInt(dataOffset) != 5919570)
            Printf("RSZ magic not found at main file header's dataOffset\n");

        if (ReadUInt(0) == id_BHVT || magic == id_mfs2) {
            if (magic == id_mfs2) {
                uint version;
                MAGIC signature;
                FSkip(8);
                uint64 treeData;
                uint64 transitionMapTbl;
                uint64 transitionDataTbl;
                uint64 treeInfoPtr;
                uint transitionMapCount;
                uint transitionDataCount;
                uint startTransitionDataIndex;
    
                FSeek(treeInfoPtr);
                uint treeDataSize;
    
                FSeek(transitionMapTbl);
                
                if (transitionMapCount) 
                    struct TRANSITIONMAP {
                        int transitionId;
                        int dataIndex;
                        if ( exists(Header.TransitionData[dataIndex])) {
                            FSeek(startof(Header.TransitionData[dataIndex]));
                            if (dataIndex > 0) {
                                struct TRANSITIONDATA TransitionData <open=true>;
                                checkUseSpacers();
                            } else
                                struct TRANSITIONDATA TransitionData;
                            FSeek(startof(dataIndex)+4);
                        }
                    } TransitionMap[transitionMapCount] <optimize=true>;
    
                FSeek(transitionDataTbl);
                if (transitionDataCount) 
                    struct TRANSITIONDATA {
                        int id <format=hex>;
                        enum {
                            EndType_None = 0x0,
                            EndType_EndOfMotion = 0x1,
                            EndType_ExitFrame = 0x2,
                            EndType_ExitFrameFromEnd = 0x3,
                            EndType_SyncPoint = 0x4,
                            EndType_SyncPointFromEnd = 0x5,
                        } endType : 4;
                        enum {
                            InterpolationMode_None = 0x0,
                            InterpolationMode_FrontFade = 0x1,
                            InterpolationMode_CrossFade = 0x2,
                            InterpolationMode_SyncCrossFade = 0x3,
                            InterpolationMode_SyncPointCrossFade = 0x4,
                            InterpolationMode_FrontOffsetFade = 0x5,
                            InterpolationMode_InertiaFade = 0x6,
                            InterpolationMode_FrontSpeedFade = 0x7,
                        } interpolationMode : 4;
                        enum {
                            InterpolationCurve_Linear = 0x0,
                            InterpolationCurve_Smooth = 0x1,
                            InterpolationCurve_EaseIn = 0x2,
                            InterpolationCurve_EaseOut = 0x3,
                        } interpolationCurve : 4;
                        uint32 prevMoveToEnd : 1;
                        enum {
                            StartType_None = 0x0,
                            StartType_Frame = 0x1,
                            StartType_NormalizedTime = 0x2,
                            StartType_SyncTime = 0x3,
                            StartType_AutoSyncTime = 0x4,
                            StartType_AutoSyncTimeSamePointCount = 0x5,
                        } startType : 4;
                        uint32 elapsedTimeZero : 1;
                        uint32 contOnLayer : 1;
                        uint32 contOnLayerInterpCurve : 4;
                        uint32 emptyBits : 9 <hidden=true>;
                        float exitFrame;
                        float startFrame;
                        float interpolationFrame;
                        if (!(RSZVersion == "RE2" && !RTVersion) && RSZVersion != "DMC5" ) {
                            float contOnLayerSpeed;
                            float contOnLayerTimeout;
                            uint16 contOnLayerNo;
                            uint16 contOnLayerJointMaskId;
                        }
                        FSkip(4);
                    } TransitionData[transitionDataCount] <optimize=true>;
                FSeek(startTransitionDataIndex+4);
            }
        }
        
        if (exists(treeData) || magic == id_BHVT) {
            if (exists(treeData))
                FSeek(treeData);
            else FSeek(startof(magic));
            struct {
                uint BHVT;
                FSkip(4);
                uint64 nodeOffset;
                uint64 actionOffset;
                uint64 selectorOffset;
                uint64 selectorCallerOffset;
                uint64 conditionsOffset;
                uint64 transitionEventOffset;
                uint64 expressionTreeConditionsOffset;
                uint64 staticActionOffset;
                uint64 staticSelectorCallerOffset;
                uint64 staticConditionsOffset;
                uint64 staticTransitionEventOffset;
                uint64 staticExpressionTreeConditionsOffset;
                uint64 stringOffset;
                uint64 resourcePathsOffset;
                uint64 userdataPathsOffset;
                uint64 variableOffset;
                uint64 baseVariableOffset;
                if (!(RSZVersion == "RE2" && !RTVersion) && RSZVersion != "DMC5")
                    uint64 referencePrefabGameObjectsOffset;
                FSeek(startof(BHVT)+16);
                struct {
                    struct ReadStruct actionOffset(0, startof(BHVT));
                    struct ReadStruct selectorOffset(0, startof(BHVT));
                    struct ReadStruct selectorCallerOffset(0, startof(BHVT));
                    struct ReadStruct conditionsOffset(0, startof(BHVT));
                    struct ReadStruct transitionEventOffset(0, startof(BHVT));
                    struct ReadStruct expressionTreeConditionsOffset(0, startof(BHVT));
                    struct ReadStruct staticActionOffset(0, startof(BHVT));
                    struct ReadStruct staticSelectorCallerOffset(0, startof(BHVT));
                    struct ReadStruct staticConditionsOffset(0, startof(BHVT));
                    struct ReadStruct staticTransitionEventOffset(0, startof(BHVT));
                    struct ReadStruct staticExpressionTreeConditionsOffset(0, startof(BHVT));
                } RSZs;
        
                FSeek(stringOffset+startof(this));
                struct BHVTStringPool{
                    if (exists(mPathNamePool) && !detectedString(FTell()+4))
                        uint numPaths;
                    if (!exists(numPaths) || numPaths > 0) {
                        uint poolSize;
                        while (FTell() < startof(this)+(poolSize*2)) {
                            if (exists(numPaths))
                                struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName2>;
                            else 
                                struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName>;
                            if (sizeof(String) == 0) 
                                break; 
                        }
                    }
                } mNamePool;
                FSeek(resourcePathsOffset+startof(this));
                struct BHVTStringPool mPathNamePool;
                if (exists(userdataPathsOffset) && ReadUInt(userdataPathsOffset+startof(this)) != 2) {
                    FSeek(userdataPathsOffset+startof(this));
                    struct BHVTStringPool mUserDataPathNamePool;
                }
                
                FSeek(userdataPathsOffset+startof(this)-4); 
                while (FTell()+8<FileSize() && ReadUInt(FTell()+4) != id_uvar) FSkip(1);
                while(FTell() + 8 < FileSize()){
                    if (exists(Uvar[0]))
                        struct UVAR Uvar <hidden=false>;
                    else struct UVAR Uvar;
                    FSeek(startof(Uvar)+8);
                    while (FTell() + 8 < FileSize() && ReadUInt(FTell()+4) != id_uvar) 
                        FSkip(1);
                }
                FSeek(baseVariableOffset+startof(this));
                
                unsigned int mReferenceTreeCount;
                if (FTell()+8 <= FileSize())
                    uint64 thisOffset;
                
                FSeek(startof(baseVariableOffset) + 8 + (8 * (!(RSZVersion=="RE2" && !RTVersion) && RSZVersion!="DMC5")));
            } BHVT;
        }
    } Header;
else {
    Printf("Header not detected\n");
    struct {
        local uint magic = ReadUInt();
        ubyte skip <hidden=true>;
    } Header;
    FSkip(-1);
}
    
    typedef struct {
        struct BHVTCount TagsCount(1); 
        if (!finished) {
            if (TagsCount.Count > 1) 
                struct { 
                    for (i=0; i<TagsCount.Count; i++) 
                        int Tags <format=hex>; 
                } Tags; 
            else if (TagsCount.Count == 1) 
                int Tags <format=hex>;
        } else {
            if (TagsCount.Count && TagsCount.Count < FileSize() && FTell() + TagsCount.Count * 4 < RSZOffset)
                if (TagsCount.Count > 1) { 
                    struct { 
                        struct BHVTHash Tags(id_Tags, "")[TagsCount.Count]; 
                    } Tags <open=true>; 
                } else 
                    struct BHVTHash Tags(id_Tags, "") <open=true>;
        }
        ubyte mIsBranch <name="Bool IsBranch">;
        ubyte mIsEnd <name="Bool IsEnd">;
    } TAGS <name="Tags & Bools">; //read=ReadTAGs, write=WriteTAGs,
    
    typedef struct  {
        if (ReadInt(FTell() + (2 * (4 * ChildCount.Count))) == -1)
            struct BHVTHash ChildNode(id_All, "") <open=true>; 
        else 
            struct BHVTHash ChildNode(id_All, ""); 
        FSkip(4 * ChildCount.Count - 4);
        struct BHVTHash ChildNodeEx(id_All, ""); FSkip(4 * ChildCount.Count - 4);
        struct BHVTId Conditions(id_Conditions, "Conditions", 0);
        FSeek(startof(ChildNode)+4);
    } nChild <name=ReadnChildName, read=ReadnChild>;

    typedef struct {
        struct BHVTHash Action(id_Actions, "") <open=true>;
        FSkip(4 * ActionsCount.Count - 4);
        struct BHVTHash ActionEx(id_Actions, "");
        FSeek(startof(Action)+4);
    } nAction <name="Action", read=ReadnAction>;

    typedef struct {
        FSeek(pos);
        if (RSZVersion == "RE8" || RSZVersion == "MHRise") {
            struct BHVTId mStartTransitionEvent(id_All, "", 1); 
            pos = FTell();
            for (j=mm+1; j<TransitionCount.Count; j++)
                fakeStateList();
            FSkip(mm * 4);
        } else {
            struct BHVTHash mStartTransitionEvent(id_All, "");          
            FSkip(4 * TransitionCount.Count - 4);
        }
        if (detectedHash(FTell()) && ReadUByte(FTell()+2) != 0) 
            struct BHVTHash mStartState(id_All, "");
        else
            struct BHVTId mStartState(id_All, "", 0);
        FSkip(4 * TransitionCount.Count - 4);
        struct BHVTId mStartStateTransition(id_Conditions, "mStartStateTransition", 0); //id_StaticConditions
        if (!(RSZVersion == "RE2" && !RTVersion) && RSZVersion != "DMC5") {
            FSkip(4 * TransitionCount.Count - 4);
            struct BHVTHash mStartStateEx(id_All, "");
        }
        FSeek(startof(this)+4);
    } nTransition <read=ReadnTransition, name=ReadnTransitionName>;
    
    typedef struct {
        FSeek(pos);
        struct BHVTId mStates(id_All, "", 1); 
        pos = FTell();
        for (j=mm+1; j<StatesCount.Count; j++)
            fakeStateList();
        FSkip(mm * 4);
        struct BHVTHash mTransitions(id_All, "");  FSkip(4 * StatesCount.Count - 4);
        struct BHVTId TransitionConditions(id_Conditions, "TransitionConditions", 0); FSkip(4 * StatesCount.Count - 4);
        if (BHVTStart == 0)
            struct BHVTHash TransitionMaps(id_All, ""); 
        else
            struct BHVTHash TransitionMaps(id_Transition, "TransitionMaps"); 
        FSkip(4 * StatesCount.Count - 4);
        struct BHVTHash mTransitionAttributes(id_All, "");  FSkip(4 * StatesCount.Count - 4);
        struct BHVTHash mStatesEx(id_All, ""); 
        FSeek(startof(mTransitions)+sizeof(mTransitions));
    } nState <read=ReadnState, name=ReadnStateName>;

    typedef struct {
        struct BHVTHash mAllState(id_All, ""); FSkip(4 * AllStateCount.Count - 4);
        struct BHVTId mAllTransition(id_Transition, "mAllTransition", 0); FSkip(4 * AllStateCount.Count - 4);
        struct BHVTHash mAllTransitionID(id_Transition, "mAllTransitionID"); FSkip(4 * AllStateCount.Count - 4);
        struct BHVTHash mAllStateEx(id_All, ""); FSkip(4 * AllStateCount.Count - 4);
        struct BHVTId mAllTransitionAttributes(id_All, "", 0);
        FSeek(startof(mAllState)+4);
    } nAllState <read=ReadnAllState, name=ReadnAllStateName>;
    
    if (exists(Header.BHVT)) {
        FSeek(Header.BHVT.nodeOffset+startof(Header.BHVT));
        struct  {
            ubyte NodeWriter <name="Node Writer", read=readNodeWriterMessage, write=WriteNewNode>;
            FSkip(-1);
            uint32 NodeCount;
            local uint32 NodeCounter <hidden=true>;
            
            struct RAWNODES { 
                typedef struct {
                    local uint32 index <hidden=true>;
                    local uint mm <hidden=true>;
                    
                    if (exists(NodeCounter)) {
                        index = NodeCounter;
                    } else { 
                        for (index=getBHVTWaypointIndex(FTell()); index<BehaviorTree.NodeCount; index++)
                            if (startof(this) == startof(BehaviorTree.RawNodes.Node[index]))
                                break;
                    }
                    
                    local ubyte isEnd <hidden=true>, isBranch <hidden=true>;
                    struct BHVTHash ID(id_All, ""); 
                    struct BHVTHash exID(id_All, "");
                    StringRead Name(-1, 4+BHVTStart+Header.BHVT.stringOffset, -1); //startof(Header.BHVT)
                    if (!exists(ID) || ID.hash != ReadInt())
                        struct BHVTHash Parent(id_All, "");
                    else 
                        int Parent;
                    struct BHVTHash ParentEx(id_All, "");
                    
                    if (ReadInt() > 0) {
                        struct nChildContainer {
                            struct BHVTCount ChildCount(3);
                            if (ChildCount.Count && ChildCount.Count < FileSize() && FTell() + ChildCount.Count * 4 < RSZOffset) {
                                for (mm=0; mm<ChildCount.Count; mm++) {
                                    if (ChildCount.Count == 1) {
                                        struct nChild Child <open=true>;
                                        checkUseSpacers();
                                    } else 
                                        struct nChild Child;
                                }
                                FSeek(startof(Child.Conditions)+4);
                            }
                        } ChildNodes <name="Child Nodes", read=ReadnChildContainer>;
                    } else 
                        struct BHVTCount ChildCount(3); 
                    
                    struct BHVTId SelectorID(id_Selectors, "", 0);
                    
                    if (ReadInt() > 0) {
                        struct {
                            struct BHVTCount SelectorCallersCount(1); 
                            if (SelectorCallersCount.Count && SelectorCallersCount.Count < FileSize() && FTell() + SelectorCallersCount.Count * 4 < RSZOffset) {
                                if (SelectorCallersCount.Count > 1) struct { struct BHVTId selectorCallers(id_SelectorCallers, "", 0)[SelectorCallersCount.Count]; } selectorCallers; else struct BHVTId selectorCallers(id_SelectorCallers, "", 0);
                            }
                        } SelectorCallers;
                    } else 
                        struct BHVTCount SelectorCallersCount(1);
                    
                    struct BHVTId SelectorCallerConditionID(id_Selectors, "", 0);
                    
                    if (ReadInt() > 0) {
                        typedef struct  {
                            struct BHVTCount ActionsCount(2);  
                            if (ActionsCount.Count && ActionsCount.Count < FileSize() && FTell() + ActionsCount.Count * 4 < RSZOffset) {
                                for (mm=0; mm<ActionsCount.Count; mm++) {
                                    if (ActionsCount.Count == 1) {
                                        struct nAction Action <open=true>;
                                        checkUseSpacers();
                                    } else 
                                        struct nAction Action;
                                    if (mm < ActionsCount.Count-1) 
                                        FSeek(startof(Action.Action)+sizeof(Action.Action));
                                }
                                FSeek(startof(Action.ActionEx)+4);
                            }
                        } nActionsContainer <name="Actions", read=ReadnActionsContainer>;
                        if (ReadInt() == 1)
                            struct nActionsContainer Actions;
                        else 
                            struct nActionsContainer Actions <open=true>;
                    } else 
                        struct BHVTCount ActionsCount(2);
                    
                    int Priority;   //if (Priority > mPriorityMax) mPriorityMax = Priority;
                    
                    if (!isAIFile) {
                        struct {
                            if (ReadInt() & 0x20) {
                                local uint mNodeAttribute <hidden=true> = ReadUInt(FTell());
                                enum <uint16> {
                                    NodeAttribute_IsEnabled = 0x1,
                                    NodeAttribute_IsRestartable = 0x2,
                                    NodeAttribute_HasReferenceTree = 0x4,
                                    NodeAttribute_BubblesChildEnd = 0x8,
                                    NodeAttribute_SelectOnce = 0x10,
                                    NodeAttribute_IsFSMNode = 0x20,
                                    NodeAttribute_TraverseToLeaf = 0x40,
                                } NodeAttribute;
                                enum <uint16> {
                                    WorkFlags_IsNotifiedEnd = 0x1,
                                    WorkFlags_HasEvaluated = 0x2,
                                    WorkFlags_HasSelected = 0x4,
                                    WorkFlags_IsCalledActionPrestart = 0x8,
                                    WorkFlags_IsCalledActionStart = 0x10,
                                    WorkFlags_IsNotifiedUnderLayerEnd = 0x20,
                                    WorkFlags_IsBranchState = 0x40,
                                    WorkFlags_IsEndState = 0x80,
                                    WorkFlags_IsStartedSelector = 0x100,
                                    WorkFlags_OverridedSelector = 0x200,
                                    WorkFlags_DuplicatedAction = 0x400,
                                    WorkFlags_IsAsRestartable = 0x800,
                                } WorkFlags;

                                struct BHVTHash mNameHash(id_NameHash, "") <format=hex>;
                                struct BHVTHash mFullnameHash(id_NameHash, "") <format=hex>;
                            } else int mNodeAttribute;
                        } Node_Attributes;
                        
                        if (Node_Attributes.mNodeAttribute & 0x20) {
                            isBranch = ReadByte(FTell()+(4+(ReadInt(FTell())*4)));
                            isEnd = ReadByte(FTell()+(5+(ReadInt(FTell())*4)));
                            //local uint branchLoc =  ((4+(ReadInt(FTell())*4)));
                            if (finished)
                                struct TAGS Tags <size=GetTagsSize>;
                            else 
                                struct TAGS Tags;
                        }
                    }

                    if (!isAIFile) {
                        if (ReadInt() > 0) {
                            struct nStatesContainer {
                                struct BHVTCount StatesCount(6);
                                local uint pos <hidden=true>;
                                if (StatesCount.Count && StatesCount.Count < FileSize() && FTell() + StatesCount.Count * 4 < RSZOffset) {
                                    
                                    for (mm=0; mm<StatesCount.Count; mm++) {
                                        pos = FTell();
                                        
                                        for (j=mm; j<StatesCount.Count; j++) //complicated...
                                            fakeStateList();
                                        FSkip(mm * 4);
                                        if (StatesCount.Count == 1) {
                                            struct nState State <open=true>;
                                            checkUseSpacers();
                                        } else 
                                            struct nState State;
                                        FSeek(startof(State.mStates)+sizeof(State.mStates));
                                    }
                                    FSeek(startof(State.mStatesEx)+4);
                                }
                            } States <name="States", read=ReadnStatesContainer>;
                        } else 
                            struct BHVTCount StatesCount(6);
                        
                        if (ReadInt() > 0) {
                            struct nTransitionsContainer {
                                local ubyte noStartState <hidden=true>;
                                if ((RSZVersion == "RE2" && !RTVersion) || RSZVersion == "DMC5") 
                                    struct BHVTCount TransitionCount(3);
                                else 
                                    struct BHVTCount TransitionCount(4);
                                local uint pos <hidden=true>;
                                if (TransitionCount.Count && TransitionCount.Count < FileSize() && FTell() + TransitionCount.Count * 4 < RSZOffset) {
                                    for (mm=0; mm<TransitionCount.Count; mm++) {
                                        pos = FTell();
                                        noStartState = FALSE;
                                        if (!detectedHash(FTell()))
                                            noStartState = TRUE;
                                        
                                        if (RSZVersion == "MHRise" || RSZVersion == "RE8") {
                                            for (j=mm; j<TransitionCount.Count; j++)
                                                fakeStateList();
                                            FSkip(mm * 4);
                                        } else if (noStartState)
                                            FSkip(4 * TransitionCount.Count);

                                        if (TransitionCount.Count == 1) {
                                            struct nTransition Transition <open=true>;
                                            checkUseSpacers();
                                        } else 
                                            struct nTransition Transition;
                                        FSeek(startof(Transition.mStartTransitionEvent)+sizeof(Transition.mStartTransitionEvent));
                                        /*if (RSZVersion == "RE2" || RSZVersion == "DMC5") //seek to start of next transition
                                            FSeek(startof(Transition.mStartTransitionEvent)+4);
                                        else if (RSZVersion == "MHRise" || RSZVersion == "RE8") {
                                            if (Transition.mStartTransitionEvent.Count.Count > 0) 
                                                Printf("at %i\n", startof(Transition.mStartTransitionEvent));
                                            
                                        }*/
                                    }
                                    if (exists(Transition.mStartStateEx))
                                        FSeek(startof(Transition.mStartStateEx)+4);
                                    else 
                                        FSeek(startof(Transition.mStartStateTransition)+4); //seek to end of struct
                                }
                            } Transitions <name="Transitions", read=ReadnTransitionsContainer>;
                            
                        } else if (!(RSZVersion == "RE2" && !RTVersion) && RSZVersion != "DMC5") 
                            struct BHVTCount TransitionCount(4);
                        else 
                            struct BHVTCount TransitionCount(3);
                        
                        
                        
                        if (exists(Node_Attributes) && (Node_Attributes.mNodeAttribute & 4) == 0) {
                            if (ReadInt() > 0) {
                                struct nAllStatesContainer {
                                    struct BHVTCount AllStateCount(5);
                                    if (AllStateCount.Count && AllStateCount.Count < FileSize() && FTell() + AllStateCount.Count * 4 < RSZOffset) {
                                        for (mm=0; mm<AllStateCount.Count; mm++) {
                                            if (AllStateCount.Count == 1) {
                                                struct nAllState AllState <open=true>;
                                                checkUseSpacers();
                                            } else 
                                                struct nAllState AllState;
                                            if (mm < AllStateCount.Count-1) 
                                                FSeek(startof(AllState.mAllState)+sizeof(AllState.mAllState));
                                        }
                                        FSeek(startof(AllState.mAllTransitionAttributes)+4);
                                    }
                                } AllStates <name="AllStates", read=ReadnAllStatesContainer>;
                            } else 
                                struct BHVTCount AllStateCount(5); 
                        }
                        int ReferenceTreeIndex;
                        
                    } else {
                        int unknownAI; 
                        if (ReadInt() > 0)
                            struct StringRead AI_Path(-1, startof(Header.BHVT.mPathNamePool) + 8, -1);
                        else
                            int AI_Path;
                    }
                    
                    if (RedetectBHVT && !finished ) { //automatic correction, seeks to next node
                        if (ReadInt()==0 || !detectedHash(FTell()) ) { //!detectedNode(FTell())
                            if (NodeCounter < NodeCount-2) {
                                ubyte blank <hidden=true>;
                                FSeek(startof(Priority)+4);
                                while (!detectedNode(FTell()) && FTell() < FileSize() - 2) {
                                    
                                    if (FTell() >=startof(blank))
                                        ushort skip <hidden=true, bgcolor=cRed>;
                                    else FSkip(2);
                                }
                                Printf("Redetected BHVT Node from %u to %u\n",  startof(blank), FTell()); 
                            }
                        }
                        if (exists(NodeCounter))
                            NodeCounter++;
                    }
                } BHVTNode <name=ReadBHVTNodeName, read=ReadBHVTNode, optimize=false, open=suppress>;
                
                local uint maxDivs <hidden=true> = NodeCount / 100 + 1;
                local uint waypoints[maxDivs] <hidden=true>; 
                local uint divCounter <hidden=true>;
                
                for (n=0; n<NodeCount; n++) { //divides list up into 100 node intervals
                    
                    if (n == 100 * divCounter) {
                        waypoints[divCounter] = FTell();
                        divCounter++;
                    }
                    struct BHVTNode Node;
                    if (FTell()>RSZOffset)
                        break;
                }
            };
            
            if (HideRawNodes) 
                struct RAWNODES RawNodes <hidden=true, open=suppress>;
            else struct RAWNODES RawNodes <open=suppress>;
            
            struct {
                uint32 ActionsObjectTableCount;
                if (ActionsObjectTableCount && ActionsObjectTableCount * 4 + FTell() < FileSize())
                    struct { uint zeroes[ActionsObjectTableCount]; } ActionsObjectTable;
                uint32 StaticActionsObjectTableCount;
                if (StaticActionsObjectTableCount && StaticActionsObjectTableCount * 4 + FTell() < FileSize()) 
                    struct { uint zeroes2[StaticActionsObjectTableCount]; } StaticActionsObjectTable;
            } zeroes;
            if (HideRawNodes) 
                FSeek(startof(this)+1);
        } BehaviorTree;
    }

        wstring ReadBHVTNodeName(BHVTNode &b) { 
            if (exists(b.isBranch)) {
                return FormBHVTNodeReaderString(b, "Node");
            } else {
                local ushort z;
                for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.NodeCount; z++)
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z])) {
                        return FormBHVTNodeReaderString(BehaviorTree.RawNodes.Node[z], "Node");
                    }
            }
            return "Node";
        }
        
        //This fn allows the nodes list to be scanned much more quickly by the reader function, dividing it up into 10ths:
        int getBHVTWaypointIndex(uint32 tell) { 
            local ushort div = BehaviorTree.RawNodes.divCounter-1;
            while (tell < BehaviorTree.RawNodes.waypoints[div / 2])
                div = div / 2;
            for (div; div>=0; div--)
                if (tell >= BehaviorTree.RawNodes.waypoints[div])
                    return div * 100;
            return 0;
        }
        
        string FormBHVTNodeReaderString(BHVTNode &b, string s) {
            local string ss = "(";
            if (exists(b.ChildNodes))                     ss += "C,";
            if (exists(b.Actions))                        ss += "A,";
            if (exists(b.Tags) && sizeof(b.Tags) > 6)     ss += "G,";
            if (exists(b.States))                         ss += "S,";
            if (exists(b.Transitions))                    ss += "T,";
            if (exists(b.AllStates))                      ss += "L,";
            if (b.isBranch) s += "*";
            if (b.isEnd)    s += "^";
            ss == "(" ? ss = "" : ss = StrDel(ss, sizeof(ss)-2, 1) + ") ";
            return s + " " + ss;
        }
        
        wstring ReadBHVTNode(BHVTNode &b) { 
            local string s;
            if (exists(b.Name.String)) {
                SPrintf(s, " [%i]", b.index);  
                return b.Name.String + s;
            } else {
                local ushort z;
                for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.NodeCount; z++)
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z])) {
                        SPrintf(s, " [%i]", z);
                        return BehaviorTree.RawNodes.Node[z].Name.String + s;
                    }
            }
            return s;
        }

        string ReadBHVTNodeNameWithVarName(BHVTNode &b, string varName) { 
            if (exists(b.isBranch)) {
                return FormBHVTNodeReaderString(b, varName);
            } else {
                local ushort z;
                for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.NodeCount; z++) {
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z])) {
                        return FormBHVTNodeReaderString(BehaviorTree.RawNodes.Node[z], varName);
                    }
                }
            }
            return varName;
        }

        int SizeBHVTNode(BHVTNode &b) {
            local ushort z;
            for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.NodeCount; z++) {
                if (startof(b) == startof(BehaviorTree.RawNodes.Node[z]))
                    return sizeof(BehaviorTree.RawNodes.Node[z]);
            }
            return 4;
        }
        
        wstring ReadBHVTStringName(StringRead &str) { 
            SPrintf(s, "%i -- ", ((startof(str) - startof(parentof(str))) - 4) / 2); 
            return s + ReadStringRead(str); 
        } 
    
        wstring ReadBHVTStringName2(StringRead &str) { 
            SPrintf(s, "%i -- ", ((startof(str) - startof(parentof(str))) - 8) / 2); 
            return s + ReadStringRead(str); 
        } 
    
        int ReadBHVTStringID(StringRead &str) { 
            return (startof(str) - startof(parentof(str)) - 4) / 2; 
        } 
        
        int GetTagsSize (TAGS &t) { return (6 + ReadUInt(startof(t)) * 4); }

        wstring ReadnChild (nChild &c) { return ReadBHVTHash(c.ChildNode); } 

        wstring ReadnChildName(nChild &n) { if (exists(n.ChildNode.Node)) return ReadBHVTNodeNameWithVarName(n.ChildNode.Node, "Child"); return ""; }

        wstring ReadnAction (nAction &a) { return ReadBHVTHash(a.Action); }

        wstring ReadnState (nState &s) { return ReadBHVTHash(s.mTransitions); }

        wstring ReadnStateName(nState &s) { if (exists(s.mTransitions.Node)) return ReadBHVTNodeNameWithVarName(s.mTransitions.Node, "State"); return ""; }

        wstring ReadnTransition (nTransition &t) { 
            if (!exists(t.mStartTransitionEvent.Count) && ReadInt(startof(t.mStartTransitionEvent))) 
                return ReadBHVTHash(t.mStartTransitionEvent); 
            if (exists(t.mStartState.hash))
                return ReadBHVTHash(t.mStartState); 
            return ReadBHVTId(t.mStartState); 
        }

        wstring ReadnTransitionName(nTransition &t) { 
            if (exists(t.mStartState.Node)) 
                return ReadBHVTNodeNameWithVarName(t.mStartState.Node, "Transition");
            else if (exists(t.mStartTransitionEvent.Node))
                return ReadBHVTNodeNameWithVarName(t.mStartTransitionEvent.Node, "Transition"); 
            else return "Transition";
        }

        wstring ReadnAllState (nAllState &a) { return ReadBHVTHash(a.mAllState); }

        wstring ReadnAllStateName(nAllState &a) { if (exists(a.mAllState.Node)) return ReadBHVTNodeNameWithVarName(a.mAllState.Node, "AllState"); return ""; }

        wstring ReadNodeTagsName(BHVTNode &n) { return ReadBHVTNodeNameWithVarName(n, "Node w/ same tag"); }

        wstring ReadnStatesContainer(nStatesContainer &c) {
            if (c.StatesCount.Count && exists(c.State[c.StatesCount.Count-1]) && c.StatesCount.Count > 1) return ReadnState(c.State[0])+" ~ "+ReadnState(c.State[c.StatesCount.Count-1]);
            return ReadnState(c.State[0]);
        }
        wstring ReadnActionsContainer(nActionsContainer &c) {
            if (exists(c.Action[c.ActionsCount.Count-1]) && c.ActionsCount.Count > 1) return ReadnAction(c.Action[0])+" ~ "+ReadnAction(c.Action[c.ActionsCount.Count-1]);
            return ReadnAction(c.Action[0]);
        }
        wstring ReadnChildContainer(nChildContainer &c) {
            if (exists(c.Child[c.ChildCount.Count-1]) && c.ChildCount.Count > 1) return ReadnChild(c.Child[0])+" ~ "+ReadnChild(c.Child[c.ChildCount.Count-1]);
            return ReadnChild(c.Child[0]);
        }
        wstring ReadnAllStatesContainer(nAllStatesContainer &c) {
            if (exists(c.AllState[c.AllStateCount.Count-1]) && c.AllStateCount.Count > 1) return ReadnAllState(c.AllState[0])+" ~ "+ReadnAllState(c.AllState[c.AllStateCount.Count-1]);
            return ReadnAllState(c.AllState[0]);
        }
        
        wstring ReadnTransitionsContainer(nTransitionsContainer &c) {
            if (exists(c.Transition[c.TransitionCount.Count-1]) && c.TransitionCount.Count > 1) return ReadnTransition(c.Transition[0])+" ~ "+ReadnTransition(c.Transition[c.TransitionCount.Count-1]);
            return ReadnTransition(c.Transition[0]);
        }
        
    typedef struct {
        HASH hash <read=ReadHASHWithName>;
        uint32 CRC;
        StringRead pathOffset(-1, 0, 0);
    } UserDataInfo <name=ReadUserDataInfoName, read=ReadUserDataInfo>;
    
        string ReadUserDataInfo (UserDataInfo &u) { return u.pathOffset.String; }
        
        string ReadUserDataInfoName(UserDataInfo &u) { return u.hash.HashName; }
    
    typedef struct {
        if ((RSZVersion == "RE7" && !RTVersion) || (Header.magic == id_PFB && ((RSZVersion == "RE2" && !RTVersion) || RSZVersion == "DMC5")))
            StringRead pathStr(FTell(), 0, 1); 
        else
            StringRead pathStr(-1, 0, 0);
        //local byte isReferenced;
    } Resource_Info <name=ReadResourceInfoName, read=ReadResourceInfo, write=WriteResourceInfo>;
    
        string ReadResourceInfo(Resource_Info &r) { return r.pathStr.String; }
    
        string ReadResourceInfoName(Resource_Info &r) { if (!exists(r.pathStr.OpenFile) && !exists(r.OpenFile)) return "*ResourceInfo"; return "ResourceInfo"; }
    
        void WriteResourceInfo(Resource_Info &r, string s) { WriteStringRead(r.pathStr, s);  }

        string ReadGameObjectString(ubyte &dd) {
            local ushort ii = RSZFile[0].ObjectTable[parentof(dd).id.id];
            local ushort compCtr;
            local string str;
            while(exists(RSZFile[0].InstanceInfos.instanceInfo[ii]) && compCtr < parentof(dd).componentCount + 1) {
                if (RSZFile[0].InstanceInfos.instanceInfo[ii].isObject) {
                    SPrintf(str, "%s *%i_%i", str, RSZFile[0].InstanceInfos.instanceInfo[ii].typeId.Hash, RSZFile[0].InstanceInfos.instanceInfo[ii].CRC);
                    compCtr++;
                } else
                    SPrintf(str, "%s %i_%i", str, RSZFile[0].InstanceInfos.instanceInfo[ii].typeId.Hash, RSZFile[0].InstanceInfos.instanceInfo[ii].CRC);
                ii++;
            }
            return str;
        }

        void CheckRSZVariable(RSZVariable &v, int greaterThan, int addAmt, byte dontChangeUserDatas) {
            local int fx;
            while(exists(v.var[fx])) {
                CheckRSZVariable(v.var[fx], greaterThan, addAmt, dontChangeUserDatas);
                fx++;
            }
            if (exists(v.ObjectIndex) && v.ObjectIndex > greaterThan)
                v.ObjectIndex += addAmt;
            if (!dontChangeUserDatas && exists(v.RSZIdx) && v.RSZIdx > greaterThan)
                v.RSZIdx += addAmt;
        }
        
        void CheckInstance(RSZInstance &r, int greaterThan, int addAmt, byte dontChangeUserDatas) {
            local int fx;
            while(exists(r.var[fx])) {
                if (exists(r.var[fx].ObjectIndex) || exists(r.var[fx].var))
                    CheckRSZVariable(r.var[fx], greaterThan, addAmt, dontChangeUserDatas);
                fx++;
            }
        }
        
        void FixObjects(int lvl, int greaterThan, int addAmt, byte dontChangeUserDatas) {
            Printf("Add amt: %i\n", addAmt);
            local int ix, sh;
            while(exists(RSZFile[lvl].Data.RawData.RSZ[ix])) {
                CheckInstance(RSZFile[lvl].Data.RawData.RSZ[ix], greaterThan, addAmt, dontChangeUserDatas);
                ix++;
            }
            ix = 0;
            while(exists(Groups.Group[ix])) {
                while(exists(Groups.Group[ix].Shape[sh])) {
                    if (Groups.Group[ix].Shape[sh].ShapeInfo.UserDataIndex > greaterThan)
                        Groups.Group[ix].Shape[sh].ShapeInfo.UserDataIndex += addAmt;
                    sh++;
                }
                ix++;
            }
        }
        
        int GetFieldSizeAtOffset(uint classHash, uint tell) {
            local uint newTell = tell;
            if (!IsInitialized())
                ParseJson(JsonPath);
            for (j=0; j<GetFieldCount(classHash); j++) {
                if (GetFieldArrayState(classHash, j) == true) {
                    newTell = getAlignedOffset(newTell, 4) + 4;
                } else {
                    newTell = getAlignedOffset(newTell, GetFieldAlignment(classHash, j)) + GetFieldSize(classHash, j);
                }
            }
            return newTell - tell;
        }

        void WriteNewRSZStructs(uint tell, string combinedKeys, int elementSz) {
            if (Atoi(combinedKeys) > 0 && Atoi(combinedKeys) < 10000) {
                InsertBytes(tell, elementSz * (Atoi(combinedKeys)), 0);
                FSkip(elementSz * (Atoi(combinedKeys)));
                Printf("Inserted %i bytes for %i new list entries at %i\n", elementSz*Atoi(combinedKeys), (Atoi(combinedKeys)), tell);
            } else if (combinedKeys != "") {
                local short tempSz, index;
                local string tmp = combinedKeys;
                
                while(index > -1) {                    
                    while(tmp[0] == 0x2A || tmp[0] == 0x20)
                        tmp = StrDel(tmp, 0, 1);

                    if ((!exists(RSZUserDataInfos) || FindFirst(classHash, 0, 0, 0, 0, 0, startof(RSZUserDataInfos), 0, 24) == -1)) { //!elementSz &&  
                        tempSz = GetFieldSizeAtOffset(Atoi(tmp), FTell());
                        if (tempSz) {
                            InsertBytes(FTell(), tempSz, 0);
                            Printf("Inserted %i bytes for new struct %s at %i\n", tempSz, GetRSZClassName(Atoi(tmp)), FTell());
                            FSkip(tempSz);
                        }
                    }
                    index = findS(tmp, " ");
                    tmp = StrDel(tmp, 0, index);
                }
            }
        }
        
        //re-aligns a RSZFile while inserting new structs:
        int fixAlignment(struct RSZVariable &r, uint insertPt, int elementSz, string combinedKeys) {
            
            local string hashOrCount = combinedKeys;
            if (exists(r.Count) && elementSz> 0) // && Atoi(combinedKeys) > 0 && Atoi(combinedKeys)  < 1000
                SPrintf(hashOrCount, "%i\n", Atoi(combinedKeys)-r.Count);
            local ubyte inserted;
            local short index = findS(hashOrCount, " ");
            local uint in = RSZFile[r.lvl].RSZHeader.instanceCount-1, f, v;
            local uint oldFileSize = FileSize();
            local uint nextTell, listCount;
            local ubyte newDataAlignment = 1;
            if (hashOrCount[0] == 0x2A) //if it is a normal combinedKey and not a count
                newDataAlignment = GetFieldAlignment(Atoi(StrDel(hashOrCount, 0, 1 + (hashOrCount[1]==0x2A))), 0);
           
            //remove padding
            while(!exists(RSZFile[r.lvl].Data.RawData.RSZ[in]) && in > -1) 
                in--;
            while(in > -1 && exists(RSZFile[r.lvl].Data.RawData.RSZ[in])) {
                f = RSZFile[r.lvl].Data.RawData.RSZ[in].fieldCount-1;
                while(f > -1 && exists(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f])) {
                    v=0; while(exists(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v])) v++; v--;
                    while(v > -1 && exists(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v])) {
                        if (RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v].padding > 0){
                            DeleteBytes(startof(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v]) - RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v].padding, RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v].padding);
                            //Printf("deleted %i bytes at %i \n", RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v].padding, startof(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v]) - RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v].padding);
                        }
                        v--;
                    }
                    if (RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].padding > 0) {
                        DeleteBytes(startof(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f]) - RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].padding, RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].padding);
                        //Printf("deleted %i bytes at %i \n", RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].padding, startof(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f]) - RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].padding);
                    }
                    f--;
                }
                in--;
            }
            
            // go back the other way
            FSeek(startof(RSZFile[r.lvl].Data.RawData.RSZ[0]));
            in=0;
            while(exists(RSZFile[r.lvl].Data.RawData.RSZ[in])) {
                f=0;
                while(exists(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f])) {
                    if (!inserted && getAlignedOffset(FTell(), newDataAlignment) >= insertPt) {
                        WriteNewRSZStructs(FTell(), hashOrCount, elementSz);
                        inserted = true;
                    }
                    //Printf("%i %i @ %i %s %i check\n", in, f, FTell(), RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].fieldName, insertPt);
                    if (!exists(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].skipFileData)) {
                        //Printf(" %i %i %i %s\n", FTell(), nextTell, RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].elementSize, hashOrCount);
                        if (RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].isList) {
                            nextTell = getAlignedOffset(FTell(), 4); 
                        } else {
                            nextTell = getAlignedOffset(FTell(), RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].align);
                        }
                        if (nextTell - FTell() > 0) { //!elementSz && 
                            InsertBytes(FTell(), nextTell - FTell(), 0);
                            //Printf("%i %i, added %i @ %i\n", in, f, nextTell - FTell(), FTell());
                            FSeek(nextTell);
                        }
                        //Printf("FTell %i, %i %i\n", FTell(), getAlignedOffset(FTell(), newDataAlignment), insertPt);
                        if (!inserted && getAlignedOffset(FTell(), newDataAlignment) >= insertPt) {
                            WriteNewRSZStructs(FTell(), hashOrCount, elementSz);
                            inserted = true;
                        }
                        if (RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].isList) {
                            FSeek(nextTell+4);
                            v=0;
                            while(exists(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v])) {
                                nextTell = getAlignedOffset(FTell(), RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v].align);
                                if (nextTell - FTell() > 0) { //!elementSz && 
                                    InsertBytes(FTell(), nextTell - FTell(), 0);
                                    //Printf("%i %i, added %i @ %i\n", in, f, nextTell - FTell(), FTell());
                                }
                                FSeek(nextTell+sizeof(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f].var[v]));
                                v++;
                            }
                        } else {
                            FSeek(nextTell+sizeof(RSZFile[r.lvl].Data.RawData.RSZ[in].var[f]));
                        }
                    }
                    f++;
                }
                in++;
            }
            if (!inserted && hashOrCount != "") {
                FSeek(insertPt);
                WriteNewRSZStructs(FTell(), hashOrCount, elementSz); 
            }
            return FileSize() - oldFileSize;
        }
        
        void addInsertBookmark() {
            for (i=0; i<GetNumBookmarks(); i++) 
                if (GetBookmarkName(i) == "RSZ_Data_InsertPt") 
                    RemoveBookmark(i);
            AddBookmark(GetCursorPos()-1, "RSZ_Data_InsertPt", "ubyte", -1, cNone, cPurple, 0);
        }

        void WriteRandomHash (uint tell) { local ubyte j; for (j=0; j<4; j++) WriteUByte(tell+j, Random(255)); }

        void WriteRandomGUID (uint tell) { local ubyte j; for (j=0; j<16; j++) WriteUByte(tell+j, Random(255)); }

        int calculatePaddingAtPoint(uint newEnd, uint oldEnd, ubyte alignment, ubyte method) {
            Printf("newEnd: %i oldEnd %i\n", newEnd, oldEnd);
            local int padding, existingPadding;
            if (method == 0)
                while ((oldEnd+existingPadding) % 16 != alignment)
                    existingPadding++;
            else if (method == 1)
                while (ReadByte(oldEnd+existingPadding) == 0) 
                    existingPadding++;
            Printf("existingPadding: %i\n", existingPadding);
            while((newEnd+padding) % 16 != (oldEnd+existingPadding) % 16 )
                padding++;
            Printf("minus Padding: %i\n", padding);
            padding -= existingPadding;
            return padding;
        }
        
        int InstanceWriterMethod(string s, ushort lvl, uint insertIndex, ubyte structType, byte flag, short fieldIndex) {
            local short i, j, ctr, padBytes, newId;
            local int cycles;
            local string tmp = s;
            
            local short gObjectSz = 0;
            if (structType == 2) //FolderInfo
                gObjectSz = 8;
            if (structType == 1) //GameObject
                Header.magic == id_PFB ? gObjectSz = 12 : gObjectSz = 32;
            local ubyte instanceSize = 8 + (RSZVersion=="RE7" && !RTVersion) * 8;
            local uint oldFileSize = FileSize();
            local short sizeToAdd;
            local short objectCtr;
            local ubyte isCount = (Atoi(s)>0 && Atoi(s)<1024);
            
            newId = RSZFile[lvl].RSZHeader.objectCount;
            if (exists(GameObjectInfos)) 
                local uint GameObjectsEnd = startof(GameObjectInfos) + sizeof(GameObjectInfos) - (Header.infoCount == 0);
            if (exists(FolderInfos))
                local uint FolderInfosEnd = startof(FolderInfos) + sizeof(FolderInfos) - (Header.folderCount == 0);            

            //calculate ObjectTable added size:
            local short index = findS(s, " ");
            local short objectsOnlySz;
            local short Arr[(sizeof(s)/4) + 2];
            while(index > -1) {
                Arr[ctr] = index + 1 + ctr;
                if (s[Arr[ctr]] == 0x2A) {
                    sizeToAdd+=instanceSize+4;
                    objectsOnlySz+=instanceSize+4;
                    objectCtr++;
                } else 
                    sizeToAdd+=instanceSize;
                tmp = StrDel(tmp, index, 1);
                index = findS(tmp, " ");
                ctr++;
            }
            
            //Parse multiple Gameobjects:
            local uint compCounts[10000], cycleIDs[10000], compCtr;
            if (structType == 1) {
                cycles = 0;
                local ubyte isGameObject;
                local char buffer[gObjectSz];
                for (i=0; i<ctr; i++) {
                    tmp = SubStr(s, Arr[i], Arr[i+1] - Arr[i]);
                    if (tmp[0] == 0x2A) {
                        tmp = StrDel(tmp, 0, 1);
                        isGameObject = GetRSZClassName(Atoi(tmp)) == "via.GameObject";
                        if (isGameObject || i == ctr - 1) {
                            newId += compCtr;
                            if (isGameObject) {
                                cycleIDs[cycles] = newId; 
                                if (cycles) {
                                    compCounts[cycles-1] = compCtr - 1 + (i == ctr - 1);
                                    Printf("GameObject %i: ID = %i, has %i components\n", cycles, cycleIDs[cycles-1], compCounts[cycles-1]);
                                }
                                compCtr = 0;
                            } else 
                                compCounts[cycles - 1] = compCtr;
                            cycles++;
                        }
                        compCtr++;
                    }
                }
                cycles -= 1;
                if (cycles == 0) {
                    Printf("ERROR: GameObjectString contains no GameObjects, aborting...\n");
                    return;
                }
            } else 
                cycles = 1;
            sizeToAdd += gObjectSz * cycles;
            
            //calculate padding
            local uint padPt = (startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos));
            local uint existingPadding;
            local int alignChangeSz;
            if (structType != 4) { //no Counts
                while(ReadByte(padPt + existingPadding) == 0 && padPt + existingPadding < startof(RSZFile[lvl].Data)) 
                    existingPadding++;
                while((padPt + sizeToAdd + padBytes ) % 16 != (padPt) % 16)
                    padBytes++;
                if (existingPadding + padBytes >= 16)
                    padBytes -= 16;
                sizeToAdd += padBytes;
            }
            
            //calculate new Data Size, insert data and fix alignment
            local uint endPadPt;
            local int endPadding;
            local uint newDataInsertPt = startof(RSZFile[lvl].Data.RawData) + sizeof(RSZFile[lvl].Data.RawData);
            if (exists(RSZFile[lvl].Data.RawData.RSZ[insertIndex]))
                newDataInsertPt = startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex]) + sizeof(RSZFile[lvl].Data.RawData.RSZ[insertIndex]);
            if (structType == 4 || insertIndex < RSZFile[lvl].RSZHeader.instanceCount-1 || (exists(BehaviorTree) || exists(RequestSets))) { //  && lvl > 0 
                if (structType == 4) { //Counts
                    //local string ss; 
                    //SPrintf(ss, "%i", Atoi(tmp)+1); 
                    //WriteInt(startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex]), Atoi(tmp));
                    newDataInsertPt = startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex]) + sizeof(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex]);
                } else if (flag != 1) {
                    FixObjects(lvl, insertIndex, ctr, 0); 
                    i=0;
                    while(exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[i])) {
                        if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[i].instanceId >= insertIndex)
                            RSZFile[lvl].RSZUserDataInfos.userDataInfo[i].instanceId += ctr;
                        i++;
                    } 
                }
                endPadPt = startof(RSZFile[lvl].Data) + sizeof(RSZFile[lvl].Data);    
                if (structType == 4) { //count
                    alignChangeSz = fixAlignment(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex], startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex])
                        + sizeof(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex]), RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[fieldIndex].elementSize, s);
                } else if (flag != 1)
                    alignChangeSz = fixAlignment(RSZFile[lvl].Data.RawData.RSZ[insertIndex].var[0], newDataInsertPt, 0, s);

                local uint newEndPadPt = endPadPt+alignChangeSz;
                endPadding = calculatePaddingAtPoint(newEndPadPt, endPadPt, startof(RSZFile[lvl].RSZHeader) % 16, 0);
                sizeToAdd += endPadding;
                sizeToAdd += alignChangeSz;
            }
            
            //fix offsets
            if (sizeToAdd) {
                if (alignChangeSz > 0 && (exists(RequestSets) || exists(BehaviorTree))) {
                    local uchar buffer[alignChangeSz];
                    ReadBytes(buffer, newDataInsertPt, alignChangeSz);
                    DeleteBytes(newDataInsertPt, alignChangeSz); //temporarily restore startof() offsets so that fixers work
                    if (exists(BehaviorTree))
                        FixBHVTOffsets(sizeToAdd, startof(RSZFile[lvl].Data));
                    if (exists(RequestSets)) { //special flag to disable fixing RCOL offsets outside their main writers
                        if (flag != 2)
                            FixRCOLOffsets(sizeToAdd, startof(RequestSets), FileSize()+sizeToAdd);
                        Header.userDataSize = sizeof(RSZFile) + sizeToAdd - endPadding - existingPadding;
                    }
                    InsertBytes(newDataInsertPt, alignChangeSz, 0);
                    WriteBytes(buffer, newDataInsertPt, alignChangeSz);
                }
            }
            if (structType == 1) {
                if (sizeof(GameObjectInfos) == 1) {
                    //if (Header.magic == id_SCN)
                    //    FixOffsets(0, startof(Header.folderInfoTbl)+40, GameObjectsEnd - startof(Header.resourceInfoTbl), FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                    //else
                    FixOffsets(0, startof(ResourceInfos), GameObjectsEnd - startof(Header.resourceInfoTbl), FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                    FixOffsets(startof(ResourceInfos), headerStrings[0], GameObjectsEnd, FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                } else {
                    FixOffsets(0, startof(ResourceInfos), GameObjectsEnd, FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                    FixOffsets(startof(ResourceInfos), headerStrings[0], GameObjectsEnd, FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                }
            } else if (structType == 2) {
                if (sizeof(FolderInfos) == 1) {
                    Header.resourceInfoTbl += gObjectSz * cycles;
                    Header.dataOffset += gObjectSz * cycles;
                    FixOffsets(startof(ResourceInfos), headerStrings[0], FolderInfosEnd, FileSize()+gObjectSz*cycles, gObjectSz * cycles, (Header.magic == id_PFB));
                } else {
                    FixOffsets(0, startof(ResourceInfos), FolderInfosEnd, FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                    FixOffsets(startof(ResourceInfos), headerStrings[0], FolderInfosEnd, FileSize()+gObjectSz*cycles, gObjectSz * cycles, 0);
                }
            }
            
            if ((!RTVersion && (RSZVersion == "RE2" || RSZVersion == "RE3")) || RSZVersion == "DMC5")
                RSZFile[lvl].RSZHeader.instanceOffset = 48 + RSZFile[lvl].RSZHeader.objectCount * 4;

            //Printf("%i %i %i %i %i %i total %i %i\n", sizeToAdd, (gObjectSz * cycles),  alignChangeSz,  endPadding, existingPadding, padBytes, 
            //    sizeToAdd - (gObjectSz * cycles) - alignChangeSz - endPadding - existingPadding - padBytes, gObjectSz * cycles);
            
            FixRSZUserDataOffsets((startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize)),
                sizeToAdd - (gObjectSz * cycles) - endPadding - alignChangeSz, alignChangeSz + endPadding, lvl); 
            
            //correct ObjectTable etc for when an instance is inserted in the middle:
            local uint objectInsertPt, objectInsertIndex = -1;
            if (startof(RSZFile[lvl].InstanceInfos) + (instanceSize * insertIndex) < padPt) {
                for (o=0; o<RSZFile[lvl].RSZHeader.objectCount; o++) {
                    if (RSZFile[lvl].ObjectTable[o] > insertIndex) {
                        if (objectInsertPt == 0) {
                            objectInsertIndex = o;
                            objectInsertPt = startof(RSZFile[lvl].ObjectTable[o]);
                        }
                        RSZFile[lvl].ObjectTable[o] += ctr;
                    }
                }
                if (objectInsertIndex != -1) {
                    if (exists(RSZHeader.userdataCount))
                        for (o=0; o<RSZFile[lvl].RSZHeader.userdataCount; o++) 
                            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].instanceId >= insertIndex)
                                RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].instanceId += ctr;
                    if (exists(GameObjectInfos) && lvl == 0) 
                        for (o=0; o<Header.infoCount; o++) {
                            if (GameObjectInfos.GameObjectInfo[o].id.id >= objectInsertIndex)
                                GameObjectInfos.GameObjectInfo[o].id.id += objectCtr;
                            else if (GameObjectInfos.GameObjectInfo[o].id.id + GameObjectInfos.GameObjectInfo[o].componentCount + 1 >= objectInsertIndex)
                                GameObjectInfos.GameObjectInfo[o].componentCount += objectCtr;
                            if (GameObjectInfos.GameObjectInfo[o].parentId.id >= objectInsertIndex)
                                GameObjectInfos.GameObjectInfo[o].parentId.id += objectCtr;
                        }
                    if (exists(FolderInfos)) 
                        for (o=0; o<Header.folderCount; o++) {
                            if (FolderInfos.FolderInfo[o].id.id >= objectInsertIndex)
                                FolderInfos.FolderInfo[o].id.id += objectCtr;
                            if (FolderInfos.FolderInfo[o].parentId.id >= objectInsertIndex)
                                FolderInfos.FolderInfo[o].parentId.id += objectCtr;
                        }
                }
            } 
            if (endPadding && newEndPadPt < FileSize())
                if (endPadding > 0) {
                    Printf("Inserting %i padding bytes at %i\n", endPadding, newEndPadPt);
                    InsertBytes(newEndPadPt, endPadding, 0);
                }else if (endPadding < 0) {
                    Printf("Deleting %i padding bytes at %i\n", -endPadding, newEndPadPt);
                    DeleteBytes(newEndPadPt, -endPadding);
                    
                }

            if (objectInsertPt == 0) 
                objectInsertPt = startof(RSZFile[lvl].ObjectTable) + sizeof(RSZFile[lvl].ObjectTable);

            if (padBytes > 0)
                InsertBytes(padPt, padBytes, 0);
            if (padBytes < 0)
                DeleteBytes(padPt, -padBytes);
            
            //insert new instanceInfos
            for (i=0; i<ctr; i++) {
                //Printf(" i %i, \n startof(RSZFile[0].InstanceInfos) %i \n instanceSize %i \n insertIndex * instanceSize %i \n adds up to %i \n plus  %i \n", 
                //    i, startof(RSZFile[lvl].InstanceInfos), instanceSize, insertIndex * instanceSize, startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize), instanceSize*i);
                InsertBytes(startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize) + instanceSize*i, instanceSize, 0);
                tmp = SubStr(s, Arr[i], Arr[i+1] - Arr[i]);
                if (tmp[0] == 0x2A)
                    tmp = StrDel(tmp, 0, 1);
                WriteUInt(startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize) + instanceSize*i, Atoi(tmp)); //Hash
                WriteUInt(4 + startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize) + instanceSize*i, Atoi(StrDel(tmp, 0, findS(tmp, "_")+1))); //CRC
            }
            //insert new objects
            objectCtr = 0;
            for (i=0; i<ctr; i++) {
                if (s[Arr[i]] == 0x2A) {
                    InsertBytes(objectInsertPt + 4*objectCtr, 4, 0);
                    WriteUInt(objectInsertPt + 4*objectCtr, insertIndex + i + 1);
                    objectCtr++;
                }
            }
            
            RSZFile[lvl].RSZHeader.instanceOffset += objectCtr*4;
            RSZFile[lvl].RSZHeader.objectCount += objectCtr;
            RSZFile[lvl].RSZHeader.instanceCount += ctr;
            
            for (i=0; i<cycles; i++) {
                if (structType == 1) {
                    ReadBytes(buffer, GameObjectsEnd - gObjectSz, gObjectSz);
                    InsertBytes(GameObjectsEnd, gObjectSz, 0);
                    WriteBytes(buffer, GameObjectsEnd, gObjectSz);
                    if (Header.magic == id_PFB) { //PFB
                        WriteInt(GameObjectsEnd, cycleIDs[i]);
                        if (i == 0)
                            WriteInt(GameObjectsEnd + 4, -1);
                        else WriteInt(GameObjectsEnd + 4, cycleIDs[0]);
                        WriteInt(GameObjectsEnd+8, compCounts[i]);
                    } else {
                        WriteRandomGUID(GameObjectsEnd);
                        WriteInt(GameObjectsEnd + 16, cycleIDs[i]);
                        if (i == 0)
                            WriteInt(GameObjectsEnd + 20, -1);
                        else WriteInt(GameObjectsEnd + 20, cycleIDs[0]);
                        WriteShort(GameObjectsEnd + 24, compCounts[i]);
                        WriteInt(GameObjectsEnd + 28, -1);
                    }
                    Header.infoCount += 1;
                    GameObjectsEnd += gObjectSz;
                }
                if (structType == 2) {
                    InsertBytes(FolderInfosEnd, gObjectSz, 0);
                    WriteInt(FolderInfosEnd, newId);
                    WriteInt(FolderInfosEnd + 4, -1);
                    Header.folderCount += 1;
                    FolderInfosEnd += gObjectSz;
                }
            }
            if (structType == 4)
                SetCursorPos(newDataInsertPt);
            else if (structType > 0) 
                SetCursorPos(startof(RSZFile[0].Data.RawData)+sizeof(RSZFile[0].Data.RawData)+sizeToAdd);
            else if (exists(RSZFile[lvl].Data.RawData.RSZ[insertIndex]))
                SetCursorPos(startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex]) +sizeof(RSZFile[lvl].Data.RawData.RSZ[insertIndex]) + sizeToAdd - endPadding - alignChangeSz // - existingPadding
                    - exists(RSZFile[lvl].Data.RawData.RSZ[insertIndex].skipFileData));
            
            for (i=0; i<GetNumBookmarks(); i++) 
                if (GetBookmarkName(i) == "RSZ_Data_InsertPt") 
                    RemoveBookmark(i);
            addInsertBookmark();
            
            Printf("Insert your new data at position %i\n", GetCursorPos());
            ShowRefreshMessage("Aligned RSZ Data must be pasted after the pink marker.\n");
            return FileSize() - oldFileSize;
        } //phew
        
        void WriteNewGameObject(ubyte &d, string s) {
            if (sizeof(s) > 9 && findS(s, "_") != -1) 
                InstanceWriterMethod(s, 0, RSZFile[0].RSZHeader.instanceCount-1, 1, false, 0);
        }
        
        string ReadGameObjectWriter(ubyte &d) { return "      [Input a GameObjectString here to add a GameObject]"; }

        //string ReadGameObjectsOffset(ubyte &o) { local string ss; SPrintf(ss, "+%i", RSZFile[0].RSZHeader.instanceCount - RSZFile[0].ObjectTable[parentof(o).id.id]); return ss; } 

        string ReadFolderInfoWriter(ubyte &f) { return "      [Input here to add a FolderInfo]"; }

        void WriteNewFolderInfo(ubyte &f, string s) { 
            local string ss;
            switch (RSZVersion) {
                case "RE7": 
                    if (!RTVersion) {
                        InstanceWriterMethod(" *-1365059124_-1512238498", 0, RSZFile[0].RSZHeader.instanceCount-1, 2, false, 0); 
                        break;
                    } //else continues on...
                case "RE2": case "RE3": case "DMC5": 
                    if (RTVersion && RSZVersion != "DMC5")
                        InstanceWriterMethod(" *-1365059124_2121287109", 0, RSZFile[0].RSZHeader.instanceCount-1, 2, false, 0); //RT method
                    else 
                        InstanceWriterMethod(" *-1365059124_246280887", 0, RSZFile[0].RSZHeader.instanceCount-1, 2, false, 0); // non-RT method for RE2,3 and DMC5
                    break;
                case "RE8": case "MHRise": InstanceWriterMethod(" *-1365059124_-1017511022", 0, RSZFile[0].RSZHeader.instanceCount-1, 2, false, 0); break;
                default: break;
            }            
        }

typedef uint64 InsertKey <read=ReadInsertHashKey, write=InsertHashKey>;
     
    wstring ReadInsertHashKey(InsertKey &k) { return "      [Input CombinedKeys here to insert new Instances]      "; }
    
    void InsertHashKey(InsertKey &k, string s) {
        if (s[0] == 0x20 && sizeof(s) > 9) {
            InstanceWriterMethod(s, parentof(parentof(parentof(k))).lvl, parentof(k).index, 0, false, 0);
        }
    }

    void AutoFixGameObjectObjects(byte &u, string s) {
        local string ss; SPrintf(ss, "%i", RSZFile[0].RSZHeader.instanceCount);
        local int addAmt = Atoi(s);
        if (addAmt == 0) 
            addAmt = InputNumber("Fix ObjectIndexes", "What is the Instance Count of the file you are transferring to?", ss);
        addAmt -= RSZFile[0].ObjectTable[parentof(parentof(u)).id.id];
        FixObjects(0, 0, addAmt, 0);
        MessageBox(idOk, "Fix ObjectIndexes", "You can now copy the bytes of the GameObject.\nRemember to undo your changes in this file after copying.");
    }
    
    wstring ReadFixObjectsMessage(byte &u) { return "      [Input here to fix ObjectIndexes for copy + paste]"; }

    wstring CollectChildGameObjectsString(struct GameObject &g) {
        local int n;
        local wstring s = ReadGameObjectString(GameObjectInfos.GameObjectInfo[g.gObjectId].GameObjectString);
        while (exists(g.GameObjects.ChildObject[n])) {
            s += CollectChildGameObjectsString(g.GameObjects.ChildObject[n]);
            n++;
        }
        return s;
    }

    string ReadCompleteGameObjectString(byte &s) { return parentof(s).CompleteGameObjectStringString; };

if (ReadUInt(0) != id_RCOL) { //no RCOL
    if (exists(Header.infoCount)) {
        struct {
            ubyte GameObjectWriter <name="GameObject Writer", read=ReadGameObjectWriter, write=WriteNewGameObject>; FSkip(-1);            
            for(m=0; m<Header.infoCount; m++)
                struct GObjectInfo {
                    local ushort index <hidden=false> = m;
                    if (Header.magic == id_PFB) {
                        ObjectId id(0);
                        ObjectId parentId(0);
                        int componentCount;
                    } else {
                        rGUID Guid;
                        ObjectId id(0);
                        ObjectId parentId(0);
                        ushort componentCount;
                        short ukn;
                        int prefabId;
                    }
                    FSkip(-2);
                    //ubyte AddGameObjectOffset <read=ReadGameObjectsOffset>;

                    struct {
                        byte ObjectIndexFixer <read=ReadFixObjectsMessage, write=AutoFixGameObjectObjects>;
                        local ushort lvl <hidden=true> = 0;
                        n = parentof(this).index;
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[RSZFile[0].ObjectTable[parentof(this).id.id]]));
                        struct GameObject Object(0);
                        FSeek(startof(this));
                        if (exists(Object.GameObjects)) {
                            local wstring CompleteGameObjectStringString <hidden=true> = CollectChildGameObjectsString(Object);
                            byte CompleteGameObjectString <read=ReadCompleteGameObjectString>;
                        } else FSkip(1);
                    } GameObject <size=1>;
                    ubyte GameObjectString <read=ReadGameObjectString, write=ParseGameObjectString>;
                } GameObjectInfo <name=ReadGRefInfoName, read=ReadGRefInfo, write=WriteGRefInfo>; 
            if (!Header.infoCount) ubyte blank <hidden=true>;
        } GameObjectInfos;
        if (!Header.infoCount) 
            FSkip(-1);
    }
    
    if (exists(Header.folderInfoTbl)) {
        FSeek(Header.folderInfoTbl);
        struct {
            ubyte FolderInfoWriter <name="FolderInfo Writer", read=ReadFolderInfoWriter, write=WriteNewFolderInfo>; FSkip(-1);
            for (i=0; i<Header.folderCount; i++)
                struct FOLDERINFO {
                    local uint idx <hidden=true> = i;
                    ObjectId id(0);
                    ObjectId parentId(0);
                } FolderInfo <name=ReadFOLDERINFOName, read=ReadFOLDERINFO>;
            if (!Header.folderCount) ubyte blank <hidden=true>;
        } FolderInfos;
        if (!Header.folderCount) FSkip(-1);
    }
    
    if (exists(Header.userdataInfoTbl) && Header.userdataInfoTbl) {
        FSeek(Header.userdataInfoTbl);
        struct {
            ubyte UserDataInfoWriter <name="UserDataInfo Writer", read=ReadNewUserDataInfoMsg, write=WriteNewUserDataInfo>; 
            if (Header.userdataCount) {
                FSkip(-1);
                UserDataInfo userDataInfo[Header.userdataCount] <optimize=false>;
            }
        } UserDataInfos;
        if (sizeof(UserDataInfos) == 1)
            FSkip(-1);
    }

    if (exists(Header.uknPFBInfoCount) && Header.uknPFBInfoCount) {
        FSeek(Header.uknPFBInfoTbl);
        struct {
	        struct {
                ObjectId InstanceID(0) <read=ReadObjectIdName>;
                ushort shortA <read=readUknPFBInfoShort>; 
                ushort shortB <read=readUknPFBInfoShort>;
                int intA;
                ObjectId GameObjectID(0);
            } uknPFBInfo[Header.uknPFBInfoCount] <optimize=false>;
        } uknPFBInfos;
    }

    if (exists(Header.resourceInfoTbl)) {
	    FSeek(Header.resourceInfoTbl);
	    struct {
            struct _ResourceInfoWriter {
                ubyte PrintList <name="Print list", read=ReadPrintResourceList, write=PrintResourceList>;
            } ResourceInfoWriter <name="ResourceInfo Writer", read=ReadNewResourceInfoMsg, write=WriteNewResourceInfo>; 
            FSkip(-1);
            local string noResourceInfoOutput <hidden=true>;
            if (Header.resourceCount)
                Resource_Info ResourceInfo[Header.resourceCount] <optimize=false>;
            if (!Header.resourceCount) 
                ubyte blank <hidden=true>;
	    } ResourceInfos;
        if (!Header.resourceCount) FSkip(-1);
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        FSeek(Header.prefabInfoTbl);
        struct {
            struct _PrefabInfoWriter {
                ubyte PrintList <name="Print list", read=ReadPrintPrefabList, write=PrintPrefabList>;
            } PrefabInfoWriter <name="PrefabInfo Writer", read=ReadNewPrefabInfoMsg, write=WriteNewPrefabInfo>; 
            FSkip(-1);
            for (i=0; i<Header.prefabCount; i++)
                struct PreFab {
                    local uint idx <hidden=true> = i;
                    struct StringRead id(-1, 0, -1);
                    int parentId;
                } PrefabInfo <name=ReadPreFabName, read=ReadPreFab, write=WritePreFab>;
        } PrefabInfos;
    }
}

    wstring ReadGRefInfo(GObjectInfo &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoName(GObjectInfo &g) { return ReadObjectIdName(g.id); }
    
    void WriteGRefInfo(GObjectInfo &g, string s) { g.parentId.id = Atoi(s); };

    wstring ReadFOLDERINFO(FOLDERINFO &f) { return ReadObjectIdTitle(f.id); }

    wstring ReadFOLDERINFOName(FOLDERINFO &f) { return ReadObjectIdName(f.id); }

    wstring ReadPreFab(PreFab &p) { return ReadStringRead(p.id); }

    void WritePreFab(PreFab &p, string s) { WriteStringRead(p.id, s); }

    string ReadNewResourceInfoMsg(struct _ResourceInfoWriter &d) { return "      [Input a filepath here to add a ResourceInfo]"; }

    string ReadNewPrefabInfoMsg(struct _PrefabInfoWriter &d) { return "      [Input a filepath here to add a PrefabInfo]"; }

    string ReadNewUserDataInfoMsg(ubyte &d) { return "      [Input a filepath here to add a UserData]"; }

    string ReadNewRSZUserDataInfoMsg(struct _RSZUserDataInfoWriter &d) {  return "      [Input a CombinedKey here to add a RSZUserData]"; }

    string ReadNewRSZUserDataInfoPathMsg(ubyte &u) { 
        if (RSZVersion == "DMC5" || (!RTVersion && RSZVersion == "RE2"))
            if (parentof(u).BufferSize > 0 && PasteBuffer[0] == 0x52 && PasteBuffer[1] == 0x53 && PasteBuffer[2] == 0x5A) 
                return "Clipboard loaded, input a CombinedKey to embed it as RSZUserData";
            else
                return "      [Input here to prepare RSZUserData clipboard bytes for insertion]";
        else return "";
    }

    string ReadPrintPrefabList(ubyte &r) { return "      [Input here to print all PrefabInfos to the Output window]"; }
    
    string ReadPrintResourceList(ubyte &r) { return "      [Input here to print all ResourceInfos to the Output window]"; }

    void PrintPrefabList(ubyte &r, string s) {
        o=0;
        local string output;
        while(exists(parentof(parentof(r)).PrefabInfo[o])) {
            SPrintf(output, "%s%s\n", output, parentof(parentof(r)).PrefabInfo[o].id.String);
            o++;
        }
        Printf(output);
    }

    void PrintResourceList(ubyte &r, string s) {
        o=0;
        local string output;
        while(exists(parentof(parentof(r)).ResourceInfo[o])) {
            SPrintf(output, "%s%s\n", output, parentof(parentof(r)).ResourceInfo[o].pathStr.String);
            o++;
        }
        Printf(output);
    }
    
    void StoreNewRSZUserDataInfoPath(ubyte &u, wstring s) { 
        //get the clipboard bytes + size:  
        local uint addedSize;      
        SetSelection(GetCursorPos(), 0);
        PasteFromClipboard();
        addedSize = GetSelSize();
        ReadBytes(PasteBuffer, GetCursorPos()-addedSize, addedSize);
        DeleteBytes(GetCursorPos()-addedSize, addedSize);
        parentof(u).BufferSize = getAlignedOffset(addedSize, 16);
        parentof(u).RSZUserDataInfoPath = s; 
    }
    
    void HeaderStringWriterMethod(wstring s, ubyte structType, uint lvl) {
        
        local int padBytes, findFirst;
        local ubyte isEmbedded = (structType == 3 && ((!RTVersion && RSZVersion == "RE2") || RSZVersion == "DMC5"));
        local uint oldInstanceCt = RSZFile[lvl].RSZHeader.instanceCount;
        if (exists(RSZFile[lvl].RSZHeader.userdataCount))
            local uint oldUserDataCt = RSZFile[lvl].RSZHeader.userdataCount;
        local uint oldFileSize = FileSize();
        local uint addedSzRecord, secAddedSzRecord;
        local wstring pathString = s;
        local uint stringSizeToAdd = sizeof(s)-2;
        local uint insertPt; 
        local uint startBound = startof(Header)+sizeof(Header);
        if (exists(GameObjectInfos)) 
            startBound += sizeof(GameObjectInfos);
        local uint endBound = headerStrings[0]+8;
        local uint stringInsertPt;
        local ubyte useClipboard;
        
        //parse multiple ResourceInfos
        local ushort ctr = 1; 
        local wstring tmp = s;
        local short idx = find(tmp, "\n");
        if (find(tmp, "\n") != -1) {
            local ushort Arr[sizeof(tmp)/8];
            while (idx != -1) {
                Arr[ctr] = idx+1;
                idx = RegExSearchW(tmp, "\n", matchSize, idx+1);                   
                ctr++;
            }
        }
        
        if (structType != 3 && ((RSZVersion == "RE7" && !RTVersion) || (Header.magic == id_PFB && ((!RTVersion && RSZVersion == "RE2") || RSZVersion == "DMC5")))) {
            insertPt = headerStrings[headerStringsCount];
            padBytes = calculatePaddingAtPoint(insertPt + stringSizeToAdd, insertPt, insertPt % 16, 1);
            if (padBytes > 0)
                InsertBytes(insertPt, padBytes, 0);
            if (padBytes < 0)
                DeleteBytes(insertPt, -padBytes);
            
            FixOffsets(0, startof(GameObjectInfos), insertPt, FileSize()+stringSizeToAdd+padBytes, stringSizeToAdd+padBytes, 0);
            InsertBytes(insertPt, stringSizeToAdd, 0);
            WriteWString(insertPt, s);
            FSeek(insertPt+1);
            while(FTell() < insertPt + stringSizeToAdd) {
                if (ReadShort(FTell()) == 2560) //newline
                    WriteShort(FTell(), 0);     //turn it into a null terminator
                FSkip(2);
            }
        } else {
            local uint sizeToAdd = 8;
            if (structType == 0) { // ResourceInfo
                insertPt = startof(ResourceInfos) + sizeof(ResourceInfos) - (Header.resourceCount == 0); 
            } else if (structType == 1) { //PrefabInfo
                insertPt = Header.prefabInfoTbl + Header.prefabCount * 8;
            } else if (structType == 2) {  //UserData
                sizeToAdd = 16;
                insertPt = Header.userdataInfoTbl + Header.userdataCount * 16;
            } else if (structType == 3) {  //RSZUserData
                sizeToAdd = 16 + 8 * isEmbedded;
                insertPt = startof(RSZFile[lvl].RSZUserDataInfos) + RSZFile[lvl].RSZHeader.userdataCount * (16 + (8 * isEmbedded));
            } 
            
            if (structType == 3) {
                
                if (!isEmbedded && RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.RSZUserDataInfoPath == "") {
                    Printf("ERROR: No filepath to write, aborting...\n");
                    return;
                } else {
                    pathString = RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.RSZUserDataInfoPath;
                    stringSizeToAdd = sizeof(pathString)-2;
                }
                Printf("path %s\n", pathString);
                local uint uidx = oldInstanceCt - (s[0] != 0x20);
                if (FindFirst(Atoi(StrDel(s,0,1))) != -1) { //if the userdata is already in the file but unused
                    for (h=0; h<RSZFile[lvl].RSZHeader.instanceCount; h++) {
                        if (ReadInt(startof(RSZFile[lvl].InstanceInfos.instanceInfo[h])) == Atoi(StrDel(s,0,1)) && !exists(RSZFile[lvl].Data.RawData[h])) {
                            uidx =  h;
                            ctr = 0;
                            //break;
                        }
                    }
                    if (ctr == 0)
                        Printf("Using existing unused UserData Instance %i\n", uidx);
                }
                //ctr = 0;
                startBound = startof(RSZFile[lvl].RSZHeader);
                if (!(RSZVersion == "RE2" && !RTVersion) && RSZVersion != "DMC5" && exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) 
                  && startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) + sizeof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) > stringInsertPt)
                    stringInsertPt = startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) + sizeof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String);
            } else {
                if (headerStringsCount)
                    stringInsertPt = headerStrings[headerStringsCount];
                else
                    stringInsertPt = RSZOffset;
            }
            
            sizeToAdd *= ctr;
            local uint clipboardBytes;
            local uint userDataInsertPt;
            if (isEmbedded) {
                sizeToAdd = 24;
                stringSizeToAdd = 0;
                stringInsertPt = insertPt;
                padBytes = calculatePaddingAtPoint(insertPt + sizeToAdd, insertPt, insertPt % 16, 1);
                sizeToAdd += padBytes;
                if (RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.BufferSize >= 52 && PasteBuffer[0]==82 && PasteBuffer[1]==83 && PasteBuffer[2]==90) {
                    useClipboard = true;
                    clipboardBytes = RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.BufferSize;
                    sizeToAdd += clipboardBytes;
                }
            } else {
                if (structType == 3)
                    sizeToAdd = 16;
                padBytes = calculatePaddingAtPoint(stringInsertPt + stringSizeToAdd + sizeToAdd, stringInsertPt, stringInsertPt % 16, 1);
                stringSizeToAdd += padBytes;
            }

            userDataInsertPt = startof(RSZFile[lvl].Data) + sizeToAdd - clipboardBytes + stringSizeToAdd;//getAlignedOffset(insertPt + 24, 16) - startof(RSZFile[lvl].RSZHeader

            Printf("HeaderStringWriterMethod: %i %i %i %i %i %i %i %i\n", insertPt, stringInsertPt, sizeToAdd, padBytes, 
                startBound, endBound, stringSizeToAdd, ctr); 
            
            if (structType == 3) {
                if (!isEmbedded) {
                    RSZFile[lvl].RSZHeader.dataOffset += sizeToAdd + stringSizeToAdd;
                    for (i=0; i<RSZFile[lvl].RSZHeader.userdataCount; i++)
                        RSZFile[lvl].RSZUserDataInfos.userDataInfo[i].path.strOffset += sizeToAdd;
                } else {
                    if (sizeof(RSZFile[lvl].RSZUserDataInfos) == 1) {
                        RSZFile[lvl].RSZHeader.dataOffset += sizeToAdd;
                        FixRSZUserDataOffsets(insertPt, 0, sizeToAdd, lvl);
                    } else {
                        FixRSZUserDataOffsets(insertPt, 24 + padBytes, 0, lvl);
                        FixRSZUserDataOffsets(userDataInsertPt, clipboardBytes, 0, lvl);
                    }
                }
            } else { //regular header strings:
                FixOffsets(0, sizeof(Header), insertPt + (sizeof(RSZFile[lvl].RSZUserDataInfos) == 1), FileSize()+sizeToAdd, sizeToAdd, 0);
                FixOffsets(0, sizeof(Header), stringInsertPt, FileSize()+stringSizeToAdd, stringSizeToAdd, 0);
                Printf("strt\n");
                FixOffsets(startBound, endBound, insertPt, FileSize()+sizeToAdd, sizeToAdd, (Header.magic == id_PFB)); //every 4-bytes, if its PFB
                Printf("end, %i \n", (Header.magic == id_PFB));
                //FixOffsets(startBound, endBound, stringInsertPt+(sizeToAdd*ctr), FileSize()+sizeToAdd+stringSizeToAdd, sizeToAdd + stringSizeToAdd, 0);
            }
            
            if (structType == 3 && Abs(Atoi(StrDel(s, 0, 1))) > 10000) {
                RSZFile[lvl].RSZHeader.userdataCount += 1;
                silenceMessages = TRUE;
                if (ctr > 0)
                    addedSzRecord = InstanceWriterMethod((string)s, lvl, RSZFile[lvl].RSZHeader.instanceCount-1, 0, false, 0);
                if (exists(UserDataInfos.UserDataInfoWriter) && MessageBox(idYes | idNo, "Insert Data", "Do you want to insert a matching UserDataInfo in the file header?") == idYes) {
                    secAddedSzRecord = FileSize();
                    WriteNewUserDataInfo(UserDataInfos.UserDataInfoWriter, pathString);
                    (FileSize() != secAddedSzRecord) ? secAddedSzRecord = FileSize()-secAddedSzRecord : secAddedSzRecord = 0;
                    WriteInt(startof(UserDataInfos)+sizeof(UserDataInfos)-(sizeof(RSZFile[lvl].RSZUserDataInfos)==1), Atoi(StrDel(s, 0, 1)));
                }
                silenceMessages = FALSE;
                if (addedSzRecord > 0) {
                    local uchar buffer[addedSzRecord];
                    ReadBytes(buffer, RSZOffset+4, addedSzRecord);
                    DeleteBytes(RSZOffset+4, addedSzRecord);
                }
            } else
                addedSzRecord = 0;
            
            if (stringSizeToAdd > 0) { 
                local ushort sizeWStr;
                InsertBytes(stringInsertPt + secAddedSzRecord, stringSizeToAdd, 0);
                if (structType == 3 && !isEmbedded) {
                    WriteWString(stringInsertPt + secAddedSzRecord, pathString);
                } else if (ctr == 1) {
                    WriteWString(stringInsertPt, s);
                } else for (h=0; h<ctr; h++) {
                    (h < ctr - 1) ? sizeWStr = Arr[h+1]-Arr[h] : sizeWStr = (sizeof(tmp)/2) - Arr[h];
                    if (sizeWStr > 0)
                        WriteWString(stringInsertPt + Arr[h]*2, WSubStr(tmp, Arr[h], sizeWStr ));
                    WriteShort(stringInsertPt + Arr[h]*2 + sizeWStr*2 - 2, 0);
                }
            }
            
            if (sizeToAdd > 0)
                InsertBytes(insertPt + secAddedSzRecord, sizeToAdd - clipboardBytes, 0);
            
            //return;
            if (structType == 3) {
                WriteInt(insertPt + secAddedSzRecord, uidx); 
                WriteInt(insertPt+4 + secAddedSzRecord, Atoi(StrDel(s,0,1)));
                if (isEmbedded) {
                    Printf("Hash of %s is %i\n", pathString, hash_wide((string)pathString));
                    WriteInt(insertPt + 8, hash_wide((string)pathString));
                    if (useClipboard) {
                        
                        WriteInt64(insertPt + 16, userDataInsertPt - startof(RSZFile[lvl].RSZHeader)+addedSzRecord);
                        Printf("Pasted %i bytes to position %i\n", RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.BufferSize, userDataInsertPt);
                        InsertBytes(userDataInsertPt, clipboardBytes, 0);
                        WriteBytes(PasteBuffer, userDataInsertPt, RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.BufferSize);
                        WriteUInt(insertPt + 12, RSZFile[lvl].RSZUserDataInfos.RSZUserDataInfoWriter.BufferSize);
                    } else {
                        while(FileSize()%16 != 0) 
                            InsertBytes(FileSize(), 1, 0);
                        WriteInt64(insertPt + 16 + secAddedSzRecord, startof(RSZFile[0].Data) - startof(RSZFile[lvl].RSZHeader) + secAddedSzRecord);
                        SetCursorPos(FileSize());
                        addInsertBookmark();
                    }
                } else {
                    WriteInt64(insertPt + 8 + secAddedSzRecord, stringInsertPt + sizeToAdd + secAddedSzRecord - (startof(RSZFile[lvl].RSZHeader) + addedSzRecord + secAddedSzRecord));
                }

                if (addedSzRecord > 0) {
                    InsertBytes(FindFirst("RSZ")+4, addedSzRecord, 0);
                    WriteBytes(buffer, FindFirst("RSZ")+4, addedSzRecord);
                }
            } else if (structType == 2) {
                WriteInt64(insertPt + 8, stringInsertPt + sizeToAdd);
            } else if (ctr > 1) {
                for (h=0; h<ctr; h++)
                    WriteUInt64(insertPt + (sizeToAdd / ctr) * h, stringInsertPt + sizeToAdd + Arr[h]*2);
            } else 
                WriteUInt64(insertPt, stringInsertPt + sizeToAdd);
        }
        
        if (structType == 0) //ResourceInfo
            Header.resourceCount += ctr;
        else if (structType == 1) //PrefabInfo
            Header.prefabCount += ctr;
        else if (structType == 2) //UserDataInfo
            Header.userdataCount += 1;
        //RSZUserDataInfo did it earlier
        
        if (isEmbedded && GetCursorPos() == FileSize()) {
            ShowRefreshMessage("An Embedded UserData must be pasted after the pink marker.\n");
        } else if (structType == 2) {
            ShowRefreshMessage("A RSZUserData in one of the RSZ levels should match this UserData.\n");
        } else {
            ShowRefreshMessage("");
        }
    }

    void WriteNewResourceInfo(struct _ResourceInfoWriter &d, wstring s) { HeaderStringWriterMethod(s, 0, 0); }

    void WriteNewPrefabInfo(struct _PrefabInfoWriter &p, wstring s) {  HeaderStringWriterMethod(s, 1, 0); }

    void WriteNewUserDataInfo(ubyte &u, wstring s) {  HeaderStringWriterMethod(s, 2, 0);  }

    void WriteNewRSZUserDataInfo(struct _RSZUserDataInfoWriter &r, wstring s) { 
        //s = " 550357568_1965550144 assets:/ObjectRoot/Prefab/Shell/Generator/Entity/Bullet/wp0000/BulletDefaultGeneratorUserData_wp0000.user.json";
        if (find(s, "/") != -1) {
            r.RSZUserDataInfoPath = SubStr(s, find(StrDel(s,0,1), " ")+2, -1);
            s = SubStr(s, 0, find(StrDel(s,0,1), " ")+1);
        }
        HeaderStringWriterMethod(s, 3, parentof(parentof(r)).lvl); 
    }
    
typedef struct {
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevelRSZ(FTell());
    uint instanceId; 
    FSkip(-1);
    
    ubyte CombinedKey <read=ReadRSZUserDataInfoCombinedKey, write=null>;
    HASH typeId <read=ReadHASHWithName>;   
    if (RSZVersion == "DMC5" || (RSZVersion == "RE2" && !RTVersion)) {
        uint JsonPathHash;
        uint dataSize;
        uint64 RSZOffset <hidden=true>;
        FSkip(-8);
        struct AbsOffset RSZOffset_Absolute(startof(RSZHeader), 8) <name="RSZOffset">;
        FSkip(-1); struct { ubyte a; local wstring String; } path <hidden=true>; //dummy
        if (RSZOffset_Absolute.OffsetAbs < FileSize() && ReadUInt(RSZOffset_Absolute.OffsetAbs) == 5919570) {
            FSeek(RSZOffset_Absolute.OffsetAbs); 
            struct  {
                struct RSZMagic UserData <open=true>;
                checkUseSpacers();
            } Embedded_UserData <size=52>;
            
        } else {
            Printf("UserData not found at RSZ[%i] RSZUserData[%i]\n", lvl, (startof(this) - startof(parentof(this))) / 24);
            local uint Possible_Offset = RSZOffset_Absolute.OffsetAbs - 52;
            while(Possible_Offset < FileSize() - 4 && Possible_Offset < RSZOffset_Absolute.OffsetAbs+53 && ReadUInt(Possible_Offset) != 5919570)
                Possible_Offset++;
            if (Possible_Offset == RSZOffset_Absolute.OffsetAbs+53)
                Possible_Offset = 0;
        }
    } else {
        StringRead path(-1, startof(RSZHeader), 0); 
    }
    FSeek(startof(this)+16 + 8 * ((RSZVersion=="RE2" && !RTVersion) || RSZVersion=="DMC5"));
} RSZUserDataInfo <name=ReadRSZUserDataInfoName, read=ReadRSZUserDataInfo>;

    string ReadRSZUserDataInfoName(RSZUserDataInfo &u) { 
        local string s; 
        if (u.instanceId > -1 && u.lvl > -1 && exists(RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId]))
            SPrintf(s, "%s[%i] ", RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId].typeId.HashName, u.instanceId);
        return s;
    }
    
    string ReadRSZUserDataInfo(RSZUserDataInfo &u) {  
        if (exists(u.RSZOffset_Absolute)) {
            local ushort lvl = getLevelRSZ(u.RSZOffset_Absolute.OffsetAbs);
            if (exists(u.JsonPathHash) && exists(RSZFile[lvl]))
                return ReadRSZMagicName(RSZFile[lvl]);
        }
        return u.path.String; 
    }

    string ReadRSZUserDataInfoCombinedKey(ubyte &u) { 
        if ((RSZVersion == "RE2" && !RTVersion) || RSZVersion == "DMC5") {
            local ubyte lvl = getLevelRSZ(parentof(u).RSZOffset_Absolute.OffsetAbs);
            if (exists(RSZFile[lvl]))
                return ReadCombinedKey(RSZFile[parentof(u).lvl].InstanceInfos.instanceInfo[parentof(u).instanceId].CombinedKey) + " " + ReadRSZMagic(RSZFile[lvl]); 
            return ReadCombinedKey(RSZFile[parentof(u).lvl].InstanceInfos.instanceInfo[parentof(u).instanceId].CombinedKey);
        }
        if (exists(RSZFile[parentof(u).lvl].InstanceInfos.instanceInfo[parentof(u).instanceId].CombinedKey)) 
            return ReadCombinedKey(RSZFile[parentof(u).lvl].InstanceInfos.instanceInfo[parentof(u).instanceId].CombinedKey) + " " + parentof(u).path.String; 
        return "";
    }

typedef struct(ubyte isFolder)
{
    local ushort lvl <hidden=true>;
    local int tempN <hidden=true>, tempJ <hidden=true>, prefabCount <hidden=true>, 
        gChildCount <hidden=true>, fChildCount <hidden=true>, id <hidden=true>;
    local int gObjectId <hidden=true> = n;
    
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());
    
    local wstring title <hidden=true>;
    isFolder == true ? (id = FolderInfos.FolderInfo[n].id.id) : (id = GameObjectInfos.GameObjectInfo[n].id.id);
    
    if (!isFolder && exists(GameObjectInfos.GameObjectInfo[n].prefabId) && GameObjectInfos.GameObjectInfo[n].prefabId != -1) {
        StringRead Prefab(startof(PrefabInfos.PrefabInfo[GameObjectInfos.GameObjectInfo[n].prefabId].id), 0, 0) <open=suppress>; 
        FSkip(-1);
        title = Prefab.String;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        for (j=0; j<Header.prefabCount; j++)
            if (PrefabInfos.PrefabInfo[j].parentId == id)
                prefabCount++;
        if (prefabCount) {
            struct {
                for (j=0; j<Header.prefabCount; j++)
                    if (PrefabInfos.PrefabInfo[j].parentId == id) {
                        StringRead Prefab(startof(PrefabInfos.PrefabInfo[j]), 0, 0) <open=suppress, name="Prefab">;
                        FSkip(-1);
                    }
                FSeek(startof(this) + 1);
            } Prefabs <name="Child Prefabs">;
            FSkip(-1);
        }
    }

    local uint counter <hidden=true>, componentCount <hidden=true>;
    if (!isFolder)
        componentCount = GameObjectInfos.GameObjectInfo[n].componentCount;
    for (counter=id; counter<id+1+componentCount; counter++) {
        if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[counter]])) {
            i = RSZFile[lvl].ObjectTable[counter];
            tempN = n;
            FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[counter]]));
            struct RSZInstance RSZ;
            n = tempN;
        }
    }
    
    if (title == "" && exists(RSZ[0].title))
        title = RSZ[0].title; 
        
    if (exists(Header.folderCount)) {        
        for (j=0; j<Header.folderCount; j++)
            if (FolderInfos.FolderInfo[j].parentId.id == id && exists(ObjectTable[FolderInfos.FolderInfo[j].id.id])) {
                if (!fChildCount)
                    FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                fChildCount++;
            }
        
        if (fChildCount) {
            struct {
                for (j=0; j<Header.folderCount; j++) {
                    if (FolderInfos.FolderInfo[j].parentId.id == id) {
                        tempN = n; tempJ = j;
                        FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                        n = j;
                        if (fChildCount == 1)
                            struct GameObject ChildFolder(1) <read=ReadGameObject, open=true>;
                        else
                            struct GameObject ChildFolder(1) <read=ReadGameObject>;
                        n = tempN; j = tempJ;
                    }
                }
                if (startof(this) > FTell())
                    FSeek(startof(this) + sizeof(ChildFolder[0]));
            } Folders <name="Child Folders">;
        }
    }
    
    for (j=0; j<Header.infoCount; j++)
        if (GameObjectInfos.GameObjectInfo[j].parentId.id == id ) {
            if (!gChildCount && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]]))
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]]));
            gChildCount++;
        }    
    
    if (gChildCount) {
        struct {
            for (j=0; j<Header.infoCount; j++) {
                if (GameObjectInfos.GameObjectInfo[j].parentId.id == id && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]])) {
                    tempN = n; tempJ = j;
                    FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]]));
                    n = j;
                    if (gChildCount == 1)
                        struct GameObject ChildObject(0) <open=true>;
                    else
                        struct GameObject ChildObject(0);
                    n = tempN; j = tempJ;
                }
            }
            if (startof(this) > FTell())
                FSeek(startof(this) + sizeof(ChildObject[0]));
        } GameObjects <name="Child GameObjects">;
    }
    
    checkUseSpacers();
    
    if (startof(this) >= FTell())
        FSeek(startof(RSZ) + sizeof(RSZ));
} GameObject <name=ReadGameObjectName, read=ReadGameObject, write=WriteGameObject>;

    wstring ReadGameObjectName(GameObject &g) { return ReadRSZInstanceName(g.RSZ[0]); }

    wstring ReadGameObject(GameObject &g) {
        local wstring s;
        if (exists(g.RSZ[0].var[0].data)) {
            s = (wstring)g.RSZ[0].var[0].data;
            if (exists(g.RSZ[0].var[5].size ) && exists(g.RSZ[0].var[5].data) && g.RSZ[0].var[5].data != "" && g.RSZ[0].name == "via.Folder")
                s += "  :  " + g.RSZ[0].var[5].data + "";
            else if (exists(g.RSZ[0].var[0].size ) && exists(g.RSZ[0].var[1].data ) && g.RSZ[0].var[1].data != "" && g.RSZ[0].name == "via.GameObject")
                s += " (" + g.RSZ[0].var[1].data + ")";
        }
        return s;
    }

    void WriteGameObject (GameObject &f, wstring s) { if (exists(f.RSZ.var[5])) WriteRSZVariable(f.RSZ.var[5], s); else WriteRSZVariable(f.RSZ.var[0], s); }

typedef struct (uint relStart, ubyte dataSize) {
    if (dataSize == 4)
        uint offset;
    else
        uint64 offset;
    local uint Relative_Start = relStart;
    local uint OffsetAbs <hidden=true> = relStart + offset;
} AbsOffset <read=ReadAbsoluteOffset, write=WriteAbsoluteOffset>;

    string ReadAbsoluteOffset (AbsOffset &a) {
        local string ss;
        SPrintf(ss, "%i", a.Relative_Start + a.offset);
        return ss;
    }
    
    void WriteAbsoluteOffset(AbsOffset &a, string s) {
        if (Atoi(s) >= a.Relative_Start)
            a.offset = Atoi(s) - a.Relative_Start;
    }

typedef struct {
    
    if (realStart != -1) {
        FSeek(realStart);
        realStart = -1;
    }
    
    typedef struct {
	    uint magic;
	    uint version;
	    int objectCount;
	    int instanceCount;
        if (RSZVersion != "RE7" || RTVersion) {
	        int userdataCount;
	        int reserved <hidden=true>;
        }
        int64 instanceOffset <hidden=true>;
        FSkip(-8);
        struct AbsOffset instanceOffset_Absolute(startof(this), 8) <name="instanceOffset">;
	    int64 dataOffset <hidden=true>;
        FSkip(-8);
        struct AbsOffset dataOffset_Absolute(startof(this), 8) <name="dataOffset">;
        if (RSZVersion != "RE7" || RTVersion) {
	        int64 userdataOffset <hidden=true>;
            FSkip(-8);
            struct AbsOffset userdataOffset_Absolute(startof(this), 8) <name="userdataOffset">;
        }
        local uint AbsoluteDataOffs <hidden=true> = dataOffset + startof(this);
        if (startof(this) != startof(parentof(this)))
            local uint TotalSize;
    } RSZHEADER <name="RSZHeader">;

    if (!ShowChildRSZs && exists(parentof(this)) && !exists(offset))
        struct RSZHEADER RSZHeader <hidden=true>;
    else 
        struct RSZHEADER RSZHeader;
    
    local ushort lvl <hidden=true> = getLevelRSZ(startof(RSZHeader)); //RSZHeader.AbsoluteDataOffs
    if (RSZVersion != "RE7" || RTVersion) 
        FSeek(startof(RSZHeader.userdataOffset)+8);
    if (RSZHeader.objectCount && !ShowChildRSZs && exists(parentof(this)) && !exists(offset))
        int ObjectTable[RSZHeader.objectCount] <hidden=true, name=ReadObjectName, read=ReadObject>;
    else if (RSZHeader.objectCount)
        int ObjectTable[RSZHeader.objectCount] <name=ReadObjectName, read=ReadObject>;
    
    if (RSZVersion != "RE7" || RTVersion)
        FSeek(startof(RSZHeader) + RSZHeader.instanceOffset);
    
    typedef struct {
        for (i=0; i< RSZHeader.instanceCount; i++) {
            struct InstanceInfo {
                local uint index <hidden=true> = i;
	            HASH typeId;
                uint CRC;
                FSkip(-8);
                int64 CombinedKey <read=ReadCombinedKey>;
                FSkip(-8);
                InsertKey NewKey;
                local ubyte isObject <hidden=true>;
                if (!i)
                    typeId.HashName = "NULL";
                if (RSZVersion == "RE7" && !RTVersion)
                    FSkip(8);
            } instanceInfo <name=ReadInstanceInfoName, read=ReadInstanceInfo>;
        }
        for (j=0; j<RSZHeader.objectCount ; j++) 
            if (exists(instanceInfo[ObjectTable[j]]))
                instanceInfo[ObjectTable[j]].isObject = true;
    } INSTANCEINFO <name="InstanceInfos">;
    
    if (!ShowChildRSZs && (exists(parentof(this)) && !exists(offset)))
        INSTANCEINFO InstanceInfos <hidden=true>;
    else 
        INSTANCEINFO InstanceInfos;
    
    if (FileSize() == 128) //empty file
        return;

    if ((exists(RSZHeader.userdataOffset) && RSZHeader.userdataCount > 0) || ((RSZVersion != "RE7" || RTVersion) && BHVTStart == -1)) {
	    FSeek(startof(RSZHeader) + RSZHeader.userdataOffset);
        typedef struct {
            struct _RSZUserDataInfoWriter {
                ubyte RSZUserDataInfoPathWriter <name="Clipboard Bytes Loader:", read=ReadNewRSZUserDataInfoPathMsg, write=StoreNewRSZUserDataInfoPath>; 
                local uint BufferSize;
                local wstring RSZUserDataInfoPath <hidden=true>;
            } RSZUserDataInfoWriter <name="RSZUserDataInfo Writer", read=ReadNewRSZUserDataInfoMsg, write=WriteNewRSZUserDataInfo>; 
            
            if (RSZHeader.userdataCount) {
                FSkip(-1);
                for (i=0; i<RSZHeader.userdataCount; i++)
                    RSZUserDataInfo userDataInfo;
            }
        } RSZUSERDATAINFOS <name="RSZUserDataInfos">;
        
        if (!FEof() && !ShowChildRSZs && (exists(parentof(this)) && !exists(offset)))
            struct RSZUSERDATAINFOS RSZUserDataInfos <hidden=true>;
        else 
            struct RSZUSERDATAINFOS RSZUserDataInfos;
        if (sizeof(RSZUserDataInfos) == 1)
            FSkip(-1);
    }
    
    local ubyte isEmbeddedUserData <hidden=true>;
    
    FSeek(RSZHeader.AbsoluteDataOffs);
    if (RSZHeader.instanceCount > 1) {
        lastVarEnd = FTell();
        struct {
            local ubyte isObject <hidden=true>;
            local ushort lvl <hidden=true> = parentof(this).lvl;
            typedef struct { 
                if (!IsInitialized())
                    ParseJson(JsonPath);
                local int lvl <hidden=true> = parentof(this).lvl;
                local int temp <hidden=true>;
                local uint maxDivs <hidden=true> = RSZFile[lvl].RSZHeader.instanceCount / 100 + 1;
                local uint waypoints[maxDivs] <hidden=true>; 
                local uint divCounter <hidden=true>;
                
                
                for (i=0; i<RSZFile[lvl].RSZHeader.instanceCount; i++) {
                    
                    if (SeekByGameObject && (RSZVersion != "RE7" || RTVersion) && !finished && RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.HashName == "via.GameObject") 
                    {
                        if (FTell()+4 <= FileSize())
                            fakeGameObject Test <hidden=true>;
                        if (lastGameObject > 0 && (Test.timeScale != 3212836864 )) { 
                            Printf("Seeking from %u to last GameObject at %u\n",  FTell(), lastGameObject); 
                            FSeek(startof(Test));
                            BLANK blank <read=ReadErrorNotice, bgcolor=cRed>;
                            FSeek(lastGameObject);
                            while (FTell() <= FileSize() - 8) {
                                if (ReadUInt(FTell()) == 3212836864 && detectedBools(FTell()-4) 
                                && (detectedString(FTell()-16) || detectedString(FTell()-20) || detectedString(FTell()-24)) )
                                    break;
                                FSkip(4);
                            }
                            lastGameObject = FTell()+4;
                            Printf("Redetected next GameObject at %u\n",  lastGameObject); 
                            FSkip(-32);
                            if (detectedString(FTell()))
                                redetectStringBehind();
                            else FSkip(8);
                            broken = false;
                            SetForeColor(cYellow);
                        } else if (FTell() > lastGameObject) {
                            lastGameObject = FTell();
                            FSeek(startof(Test));
                            SetForeColor(cNone);
                        }
                    }
                    temp = FTell();
                    if (GetFieldArrayState(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))
                        FSeek(getAlignedOffset(FTell(), 4));
                    else
                        FSeek(getAlignedOffset(FTell(), GetFieldAlignment(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))); 
                    
                    //Set waypoint for reader, dividing the list up for quicker scanning:
                    if (i == 100 * divCounter) {
                        waypoints[divCounter] = FTell();
                        divCounter++;
                    }
                    
                    if (!i) {
                        struct RSZInstance RSZ <hidden=true>;
                    } else
                        struct RSZInstance RSZ;
                    
                    if (sizeof(RSZ) == 0) 
                        Printf("Empty struct: %u\n", FTell()); 
                    if (exists(RSZ.skipFileData) || i == 0) {
                        FSeek(temp);
                    } else if (exists(RSZ.skip)) {
                        if (i)
                            Printf("\nERROR: Missing struct for %X %s [%u]\n", RSZ.hash, RSZ.name, RSZ.idx);
                        FSeek(temp);
                    }
                }
            } DATA <name="RawData">;
            SetForeColor(cNone);
            if (HideRawData  || (!ShowChildRSZs && (!exists(offset) && exists(parentof(parentof(parentof(this))))))) //if is an embedded RSZMagic
                struct DATA RawData <hidden=false, open=suppress>;
            else
                struct DATA RawData <open=suppress>;

            SetForeColor(cNone);
            finished = TRUE;

            isEmbeddedUserData = false;
            if (RSZHeader.objectCount > 0 && Header.magic == 5395285 || findS(ReadObject(ObjectTable[RSZHeader.objectCount-1]), "assets:") != -1 )
                isEmbeddedUserData = true;

            if (Nesting && (Header.magic != id_RCOL && Header.magic != id_BHVT && Header.magic != id_mfs2) ) { //no RCOL, MFS2 or BHVT
                if (exists(Header.dataOffset) && startof(RSZFile[lvl].RSZHeader) == Header.dataOffset ) {
                    local ushort n <hidden=true>;
                    if (exists(Header.folderCount))
                        for (n=0; n<Header.folderCount; n++) {
                            if (FolderInfos.FolderInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]]));
                                struct GameObject MainFolder(1)  <name=ReadGameObjectName, read=ReadGameObject, write=WriteGameObject>;
                            }
                        }
                    if (exists(Header.infoCount))
                        for (n=0; n<Header.infoCount; n++) {
                            if (GameObjectInfos.GameObjectInfo[n].id.id > -1 && GameObjectInfos.GameObjectInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[GameObjectInfos.GameObjectInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[GameObjectInfos.GameObjectInfo[n].id.id]]));
                                struct GameObject MainObject(0)  <name=ReadGameObjectName, read=ReadGameObject>;
                            } 
                        }
                }
                
                if ((!exists(this.MainObject) && !exists(this.MainFolder))) {
                    for (i=1; i<RSZHeader.instanceCount; i++) {
                        if (exists(RawData.RSZ[i])) {
                            isObject = InstanceInfos.instanceInfo[i].isObject; 
                            if (isObject) {
                                FSeek(startof(RawData.RSZ[i]));
                                if (RSZHeader.objectCount == 1) {
                                    struct RSZInstance RSZ <open=true>;
                                    checkUseSpacers();
                                } else 
                                    struct RSZInstance RSZ;
                                if (exists(RawData.RSZ[i].skip) || exists(RawData.RSZ[i].skipFileData)) 
                                    FSeek(startof(RSZ));
                            }
                        }
                    }
                }
            }
            FSeek(startof(RawData) + sizeof(RawData));
            SetForeColor(cNone);
        } Data <name="Data", open=true>;
    } else 
        { FSkip(-1); ubyte Data <hidden=true>; }
    
    if (exists(parentof(this)))
        checkUseSpacers();
    
    local int f <hidden=true>, ff <hidden=true>;
    if (ShowChildRSZs && (RSZHeader.userdataCount && (RSZVersion == "DMC5" || (RSZVersion == "RE2" && !RTVersion))) ) {
        FSeek(RSZUserDataInfos.userDataInfo[0].RSZOffset_Absolute.OffsetAbs);
        struct {
            for (f=0; f<RSZHeader.userdataCount; f++) {
                FSeek(RSZUserDataInfos.userDataInfo[f].RSZOffset_Absolute.OffsetAbs);
                struct RSZMagic UserData <size=SizeRSZMagic, fgcolor=cNone>;
            }
        } UserData;
    }
    FSeek(startof(Data)+sizeof(Data));
    if (exists(this.RSZHeader.TotalSize))
        this.RSZHeader.TotalSize = FTell()-startof(RSZHeader);
} RSZMagic <name="RSZ", name=ReadRSZMagicName, read=ReadRSZMagic>;
    
    wstring ReadRSZMagicName(RSZMagic &m) { 
        if (exists(Header.BHVT) && exists(m.RSZHeader)) {
            local BHVTlvl f;
            for (f=0; f<11; f++)
                if (BHVTStart + ReadUInt64(BHVTStart + 16 + (f * 8)) == startof(m.RSZHeader))
                    return StrDel(EnumToString(f), 0, 3);
            return m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName; 
        } else if (exists(m.ObjectTable) && m.ObjectTable[0] >= 0 && exists(m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName)) {
            return m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName; 
        } else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f].RSZHeader) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName) ) 
                    return RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName;
            }
        }
        return "RSZ"; 
    }

    wstring ReadRSZMagic(RSZMagic &m) { 
        if (exists(m.Data.RSZ[0].title)) 
            return m.Data.RSZ[0].title;
        else if (exists(m.Data.MainObject[0].title))
            return m.Data.MainObject[0].title;
        else if (exists(m.Data.MainFolder[0].title))
            return m.Data.MainFolder[0].title;
        else if (finished) {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f].RSZHeader) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title) ) 
                    return RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title;
            }
        } else if ((RSZVersion == "RE2" && !RTVersion) || RSZVersion == "DMC5") {
            local int tst = FindFirst((wstring)"assets:",1,0,0,0.0,1,startof(m),0,24);
            if (tst != -1)
                return ReadWString(tst);
        }
        return ""; 
    }

    int SizeRSZMagic(RSZMagic &r) {
        if (finished) {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f].RSZHeader) == startof(r)) 
                    return sizeof(RSZFile[f]);
            }
        } return 52;
    }

    wstring ReadObjectName(int &o) { 
        local ushort lvl = parentof(o).lvl;
        if (startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + (8*(1+(RSZVersion=="RE7" && !RTVersion))) * o <= FileSize()-4) {
            local uint hash = ReadUInt((startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + (8*(1+(RSZVersion=="RE7" && !RTVersion))) * o));
            return ReadHashName(hash); 
        }
        return "";
    }

    wstring ReadObject(int &o) { 
        local ushort lvl = parentof(o).lvl;
        local string s;
        if (exists(RSZFile[lvl].Data.RawData.RSZ[o])) {
            SPrintf(s, "%i -- ", o);
            return s +  RSZFile[lvl].Data.RawData.RSZ[o].title;
        } return "";
    }

    string ReadInstanceInfoName(InstanceInfo &i) { if (i.isObject) return "*" + i.typeId.HashName;  return i.typeId.HashName;}
    
    string ReadInstanceInfo(InstanceInfo &i) { string s; SPrintf(s, "%X", i.typeId.Hash); return s; }

    string ReadCombinedKey(int64 &k) {
        local string ss = " ";
        if (parentof(k).isObject) ss+="*";
        SPrintf(ss,"%s%i_%i", ss, parentof(k).typeId.Hash, parentof(k).CRC);
        return ss;
    }


int getBHVTLevel(BHVTlvl lv) {
    local byte ret;
    switch (lv) {
        case 0: ret = getLevelRSZ(Header.BHVT.actionOffset+BHVTStart); break;
        case 1: ret = getLevelRSZ(Header.BHVT.selectorOffset+BHVTStart); break;
        case 2: ret = getLevelRSZ(Header.BHVT.selectorCallerOffset+BHVTStart); break;
        case 3: ret = getLevelRSZ(Header.BHVT.conditionsOffset+BHVTStart); break;
        case 4: ret = getLevelRSZ(Header.BHVT.transitionEventOffset+BHVTStart); break;
        case 5: ret = getLevelRSZ(Header.BHVT.expressionTreeConditionsOffset+BHVTStart); break;
        case 6: ret = getLevelRSZ(Header.BHVT.staticActionOffset+BHVTStart); break;
        case 7: ret = getLevelRSZ(Header.BHVT.staticSelectorCallerOffset+BHVTStart); break;
        case 8: ret = getLevelRSZ(Header.BHVT.staticConditionsOffset+BHVTStart); break;
        case 9: ret = getLevelRSZ(Header.BHVT.staticTransitionEventOffset+BHVTStart); break;
        case 10: ret = getLevelRSZ(Header.BHVT.staticExpressionTreeConditionsOffset+BHVTStart); break;
        default: ret = -1; break;
    }
    return ret;
}

typedef struct (string uuid) {
    local uint uv <hidden=true>, vr <hidden=true>, fd <hidden=true>, result <hidden=true>, n <hidden=true>;
    local string Guid <hidden=true> = parentof(this).Guid;
    while(exists(GameObjectInfos.GameObjectInfo[n])) {
        if (TranslateGUID(GameObjectInfos.GameObjectInfo[n].Guid.uuid) == Guid) {
            FSeek(startof(RSZFile[0].Data.RawData.RSZ[RSZFile[0].ObjectTable[GameObjectInfos.GameObjectInfo[n].id.id]]));
            i = GameObjectInfos.GameObjectInfo[n].id.id;
            struct GameObject Object(0);
            break;
        }
        n++;
    }
    local uint RSZIdx <hidden=true>;

    if (exists(Header.BHVT.Uvar)) {
        local uint vd <hidden=true>;
        while (exists(Header.BHVT.Uvar[uv])) {
            //Printf("%i\n",uv);
            for (i=0; i<Header.BHVT.Uvar[uv].variableCount; i++) {
                if (exists(Header.BHVT.Uvar[uv].Data.Var[i].VarData)) {
                    for (vd=0; vd<Header.BHVT.Uvar[uv].Data.Var[i].VarData.propCount; vd++) {
                        if (exists(Header.BHVT.Uvar[uv].Data.Var[i].VarData.Node[vd].Value.value.uuid) 
                        && TranslateGUID(Header.BHVT.Uvar[uv].Data.Var[i].VarData.Node[vd].Value.value.uuid) == Guid) {
                            FSeek(startof(Header.BHVT.Uvar[uv].Data.Var[i]));
                            struct UVARIABLE UvarRef;
                        }
                    }
                }
            }
            uv++;
        }
        uv=0;
        while (exists(Header.BHVT.Uvar[uv])) {
            for (i=0; i<Header.BHVT.Uvar[uv].header.variableCount; i++) {
                if (TranslateGUID(Header.BHVT.Uvar[uv].HashData.GUIDs.GUIDs[i].uuid) == Guid) {
                    FSeek(startof(Header.BHVT.Uvar[uv].Data.Var[Header.BHVT.Uvar[uv].HashData.dataHashMap[i]]));
                    struct UVARIABLE Uvariable <open=true>;
                    break;
                }
            }
            uv++;
            if (exists(Uvariable)) 
                break;
        }
        if (!exists(Uvariable)) {
            FSkip(-1);
        }
    }
    uv = 0;
    while (exists(RSZFile[uv])) {
        vr = 0;
        while (exists(RSZFile[uv].Data.RawData.RSZ[vr])) {
            fd = 0;
            while (exists(RSZFile[uv].Data.RawData.RSZ[vr].var[fd])) { 
                if (exists(RSZFile[uv].Data.RawData.RSZ[vr].var[fd].Guid.uuid)) { 
                //&& startof(RSZFile[uv].Data.RawData.RSZ[vr].var[fd]) !=  startof(RSZFile[uv].Data.RawData.RSZ[vr].var[fd])) {
                    result = (CheckFieldGUIDs(RSZFile[uv].Data.RawData.RSZ[vr].var[fd], Guid));
                    if (result) { 
                        FSeek(startof(RSZFile[uv].Data.RawData.RSZ[vr]));
                        RSZIdx = vr; 
                        struct RSZInstance RSZ;
                        break;
                    }
                }
                fd++;
            }
            vr++;
        }
        uv++;
    }
    if (exists(RequestSets)) {
        uv = 0;
        while (exists(Groups.Group[uv])) {
            if (TranslateGUID(Groups.Group[uv].GroupInfo.Guid.uuid) == Guid || TranslateGUID(Groups.Group[uv].GroupInfo.LayerGuid.uuid) == Guid) {
                FSeek(startof(Groups.Group[uv]));
                struct RcolGroup Group;
            } else {
                for (vr=0; vr<Groups.Group[uv].GroupInfo.NumMaskGuids; vr++)
                    if (TranslateGUID(Groups.Group[uv].GroupInfo.Guid.uuid) == Guid) {
                        FSeek(startof(Groups.Group[uv]));
                        struct RcolGroup Group;
                    }
            }
            uv++;
        }
    }
    FSeek(startof(this)+1);
    checkUseSpacers();
} SAMEGUIDS; 

int CheckFieldGUIDs(RSZVariable &v, string Guid) {
    if (exists(v.Guid.uuid) && TranslateGUID(v.Guid.uuid) == Guid)
        return true;
    local ushort d;
    while (exists(v.var[d])) {
        if (CheckFieldGUIDs(v.var[d]), Guid)
            return true;
        d++;
    }
    return false;
}

typedef struct(BHVTlvl lv, string Name, ubyte isList) {
    local string Name <hidden=true> = Name;
    local BHVTlvl Type <hidden=true> = lv;
        
    if (isList) { //for mStates and RE8 mStartTransitionEvent
        struct BHVTCount Count(1);
        if (Count.Count == 1) { 
            struct BHVTId ID(Type, "", 0) <open=true>; 
            checkUseSpacers(); 
        } else if (Count.Count) 
            struct { 
                struct BHVTId ID(Type, "", 0)[Count.Count]; 
            } IDs;
        k=0;
        while(exists(ID[k])) {
            FSeek(startof(ID[k]));
            struct BHVTIDStrings {
                StringRead Name(-1, 4+startof(Header.BHVT)+Header.BHVT.stringOffset, -1); FSkip(-4);
                StringRead User(-1, 8+startof(Header.BHVT)+Header.BHVT.userdataPathsOffset, -1); FSkip(-4);
                StringRead Path(-1, 8+startof(Header.BHVT)+Header.BHVT.resourcePathsOffset, -1);
            } Strings;
            k++;
        }
        FSeek(startof(Count) + 4 + Count.Count*4);
    } else {
        ushort id;
        ubyte ukn;
        ubyte idType;
        if (idType == 64 && Type == id_Conditions)
            Type = id_StaticConditions;
        
        if (finished && (id > -1 || (id == 0 && idType == 64))) {
            local short lvl <hidden=true> = getBHVTLevel(Type);

            if (lvl > -1 && exists(RSZFile[lvl].ObjectTable[id]) && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id]])) { //
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id]]));
                local ushort RSZIdx <hidden=true> = (uint)RSZFile[lvl].ObjectTable[id];
                struct RSZInstance RSZ <open=true>;  //
                local int vr <hidden=true>, uv <hidden=true>;
                while (exists(this.RSZ.var[vr])) {
                    if (exists(this.RSZ.var[vr].Guid.uuid) && ReadUInt(startof(this.RSZ.var[vr].Guid)) != 0) {
                        break;
                    } vr++;
                }
                if (exists(this.RSZ.var[vr].Guid.uuid) && ReadUInt(startof(this.RSZ.var[vr].Guid.uuid))) {
                    local string Guid <hidden=true>  = TranslateGUID(this.RSZ.var[vr].Guid.uuid);
                    struct SAMEGUIDS SameGUIDs(Guid) <name="Same GUID", open=true>;
                    checkUseSpacers();
                }
            } else if (exists(Header.TransitionMap[id])) {
                FSeek(startof(Header.TransitionMap[id]));
                struct TRANSITIONMAP TransitionMap <open=true>;
                checkUseSpacers();
            } 
            FSeek(startof(id)+4);
        }
    }
} BHVTId <open=suppress, optimize=false, name=ReadBHVTIdName, read=ReadBHVTId, write=WriteBHVTId>;


    wstring ReadBHVTId(BHVTId &i) { 
        string s;
        if (exists(i.id)) {
            if (exists(i.RSZ)) 
                return ReadRSZInstanceName(i.RSZ); 
            if (ReadUByte(startof(i)+3) == 0)
                SPrintf(s, "%i", i.id);
            else 
                SPrintf(s, "%i", ReadInt(startof(i)));
        } else if (exists(i.Count) && i.Count.Count > 0 && exists(i.ID))
            return ReadBHVTId(i.ID); 
        else 
            SPrintf(s, "%i", i.Count.Count);
        return s;
    } 

    string ReadBHVTIdName(BHVTId &i) { 
        if (i.Name != "" && i.Type != id_All) 
            return i.Name + " [" + StrDel(EnumToString(i.Type), 0, 3) + "]"; 
        return ""; 
    }

    void WriteBHVTId(BHVTId &i, string s) { local uint out = Atoi(s); WriteUInt(startof(i), out); } 

typedef struct(BHVTlvl lv, string Name) {
    local string Name <hidden=true> = Name;
    local BHVTlvl Type <hidden=true> = lv;
    
    int hash <format=hex>;
    if (finished && hash != -1 && hash != 0) {
        local short lvl <hidden=true> = getBHVTLevel(Type);
        if (Type == id_Transition) {
            if (detectedStringSm(startof(Header.BHVT.mPathNamePool) + 8 + hash * 2) && sizeof(ReadWString(startof(Header.BHVT.mPathNamePool) + 8 + hash * 2)) > 10) {
                struct StringRead Path(-1, startof(Header.BHVT.mPathNamePool) + 8 + hash * 2, -1);
            } else {
                m=0;
                while(exists(Header.TransitionMap[m])) {
                    if (Header.TransitionMap[m].transitionId == hash) {
                        FSeek(startof(Header.TransitionMap[m]));
                        struct TRANSITIONMAP TransitionMap <open=true>;
                        break;   
                    }
                    m++;
                }
            }
        } else if (Type == id_NameHash) {// && exists(Header.BHVT.Uvar)
            local uint uv <hidden=true>;
            while (exists(Header.BHVT.Uvar[uv])) {
                for (i=0; i<Header.BHVT.Uvar[uv].variableCount; i++) {
                    if (Header.BHVT.Uvar[uv].Data.Var[i].nameHash == hash) {
                        FSeek(startof(Header.BHVT.Uvar[uv].Data.Var[i]));
                        struct UVARIABLE Uvariable;
                    }
                }
                uv++;
            }
        } else if (detectedHash(startof(hash))) {
            local int kk <hidden=true>, tg <hidden=true>, valueStart <hidden=true>, doExit <hidden=true>;
            if (lvl == -1) {
                while (exists(BehaviorTree.RawNodes.Node[kk]) ) {
                    if (Type == id_Tags) {
                        if (BehaviorTree.RawNodes.Node[kk].Tags.TagsCount.Count > 1) {
                            for (tg=0; tg<BehaviorTree.RawNodes.Node[kk].Tags.TagsCount.Count; tg++) {
                                valueStart = 0;
                                if ((exists(BehaviorTree.RawNodes.Node[kk].Tags.Tags.Tags[tg]) && BehaviorTree.RawNodes.Node[kk].Tags.Tags.Tags[tg] == hash )
                                || (!exists(BehaviorTree.RawNodes.Node[kk].Tags.Tags.Tags) && exists(BehaviorTree.RawNodes.Node[kk].Tags.Tags) && BehaviorTree.RawNodes.Node[kk].Tags.Tags == hash) ) {
                                    valueStart = startof(BehaviorTree.RawNodes.Node[kk]);
                                    if (!exists(ID) || startof(ID) != valueStart) {
                                        FSeek(valueStart);
                                        struct BHVTNode Node <name=ReadNodeTagsName, size=SizeBHVTNode>;
                                    }
                                } 
                            }
                        }
                    } else if (hash == BehaviorTree.RawNodes.Node[kk].ID.hash || hash == BehaviorTree.RawNodes.Node[kk].exID.hash) {
                        valueStart = startof(BehaviorTree.RawNodes.Node[kk]);
                        if (!exists(ID) || startof(ID) != valueStart) {
                            FSeek(valueStart);
                            struct BHVTNode Node <size=SizeBHVTNode, open=true>;
                        }
                        if (Type != id_Tags)
                            doExit = true;
                        break;
                    }
                    kk++;
                }
            }
            
            if (FindFirst(hash,1,0,0,0.0,1,RSZOffset,0,24) != -1) { //search for RSZ structs
                (Type == -1) ? j=0 : j=lvl; 
                if (j==-1 || !exists(RSZFile[j]))
                    j=0;
                while(exists(RSZFile[j])) { 
                    i = 0;
                    while (exists(RSZFile[j].Data.RawData.RSZ[i])) {
                        k = 0;
                        while(exists(RSZFile[j].Data.RawData.RSZ[i].var[k])) {
                            if (exists(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) 
                                if (startof(hash) != startof(RSZFile[j].Data.RawData.RSZ[i].var[k].data) && ReadInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) == hash) { // || 
                                    FSeek(startof(RSZFile[j].Data.RawData.RSZ[i]));
                                    lvl = j;
                                    struct RSZInstance RSZ <open=true>; //size=SizeRSZInstance, 
                                    if (Type != id_Tags) {
                                        doExit = true;
                                        break;
                                    }
                                } 
                            k++;
                        }
                        i++;
                        if (doExit) 
                            break;
                    }
                    if (doExit || ((Type != -1 && Type != id_Actions) && (!exists(RSZFile[j+1]) || RSZFile[j+1].isEmbeddedUserData == false) )) 
                        break;
                    j++;
                }
            }
        }
        if (exists(this.Node) || exists(this.RSZ) || exists(this.TransitionMap))
            checkUseSpacers();
        FSeek(startof(hash)+4);
    }
} BHVTHash <open=suppress, optimize=false, name=ReadBHVTHashName, read=ReadBHVTHash, write=WriteBHVTHash>;

    wstring ReadBHVTHash(BHVTHash &h) { 
        if (exists(h.Node)) 
            return ReadBHVTNode(h.Node); 
        if (exists(h.RSZ)) 
            return ReadRSZInstanceName(h.RSZ); 
        if (exists(h.Path))
            return ReadStringRead(h.Path);
        string s; 
        if (Abs(h.hash) > 9999)
            SPrintf(s, "%Xh", h.hash);
        else 
            SPrintf(s, "%i", h.hash);
        return s; 
    } 

    string ReadBHVTHashName(BHVTHash &h) { 
        if (h.Name != "" && h.Type != id_All) 
            return h.Name + " [" + StrDel(EnumToString(h.Type), 0, 3) + "]"; 
        return ""; 
    }
    
    void WriteBHVTHash(BHVTHash &h, string s) { 
        if (s == "h")
            WriteRandomHash(startof(h.hash));
        local uint out = Atoi(s); WriteUInt(startof(h.hash), out); 
    } 

    //wstring ReadBHVTHashName(BHVTHash &h) { if (exists(h.RSZ)) return h.RSZ.name; return ""; } 

    int isActiveHash(BHVTHash &hash) {  return (hash.hash != 0 && hash.hash != -1) && (exists(hash.Node) || exists(hash.RSZ) || exists(hash.TransitionMap)); }

    int showHash(BHVTHash &hash){
        if (isActiveHash(hash)) {
            FSeek(startof(hash));
            return true;
        } return false;
    } 




//Start of RSZ Data =====================
if (RSZOffset > -1) {
    FSeek(RSZOffset);
    if (ReadUInt(0) == id_PFB || ReadUInt(0) == id_SCN) // SCN or PFB
        { FSkip(-1); BLANK __; FSkip(-1); BLANK ___ <name=ReadMainDataNotice>; }
    while (FTell()+4 <= FileSize()) {
        if ( ReadUInt(FTell()) == 5919570 ) { //RSZ
            finished = false;
            if (level == 1 && !FEof()) { 
                if (Header.magic == id_PFB || Header.magic == id_SCN) {
                    FSkip(-1); BLANK blank; 
                    FSkip(-1); BLANK userDataNotice <name=ReadUserDataNotice>; 
                }
            }
            if (ReadUInt(FTell()+8) == 0)
                struct RSZMagic RSZFile <hidden=true>;
            else {
                //start at struct Data if there are embedded userdatas:
                if (ExposeUserDatas && ReadInt(FTell()+16) && (exists(GameObjectInfos.GameObjectInfo) || exists(BehaviorTree)) && (RSZVersion == "DMC5" || (RSZVersion == "RE2" && !RTVersion))) { //has UserDatas
                    realStart = FTell();
                    FSeek(ReadUInt(realStart+32) + realStart);
                    struct RSZMagic RSZFile;
                } else 
                    struct RSZMagic RSZFile;
            }
            level++;
            FSeek(startof(RSZFile.RSZHeader) + 4);
        } else 
            FSkip(1);
    }
}
finished = true;

if (exists(Header.skip)) { //detect strings in motbank etc files:
    FSeek(0);
    HashGenerator HashMaker <name="Hash Generator">;
    FSkip(-1);
    while(FTell() + 6 <= FileSize())
        if (detectedString(FTell()))
            StringRead Detected_String(FTell(), 0, true); //absolute
        else 
            FSkip(2);
}

//BehaviorTree
if (exists(BehaviorTree.RawNodes)) {
    FSeek(startof(BehaviorTree.RawNodes));
    checkUseSpacers();
    struct {
        local ushort az <hidden=true>;
        for (az=0; az<BehaviorTree.NodeCount; az++) {
            if (az==0) {
                struct BHVTNode Node <name="Root Node", open=true>;
                checkUseSpacers();
            } else 
                struct BHVTNode Node <size=SizeBHVTNode>;
        }
    } Nodes;
} 


void WriteNewRequestSet(ubyte &r, string s) {
    local uint requestSetInsertPt = startof(RequestSets)+sizeof(RequestSets);
    local uint groupInsertPt = startof(Groups)+sizeof(Groups);
    local wstring nameString = InputString("Insert RequestSet", "Input a new name for your RequestSet", "NewRequestSet");
    local uchar buffer[80];
    local uint oldFileSize = FileSize();
    
    local uint instanceMethodSize = InstanceWriterMethod(s, 0, RSZFile[0].ObjectTable[Header.numRequestSets-1], 0, 2, 0);
    local char newInstanceBytes[instanceMethodSize];

    local uint newInstancesInsertPt = RSZOffset+4; // startof(RSZFile.Data.RawData.RSZ[Header.numRequestSets-1]);

    ReadBytes(newInstanceBytes, newInstancesInsertPt, instanceMethodSize);
    DeleteBytes(newInstancesInsertPt, instanceMethodSize);
    
    FixRCOLOffsets(48, requestSetInsertPt, FileSize()+48+instanceMethodSize+80);
    FixRCOLOffsets(instanceMethodSize, startof(RSZFile.InstanceInfos)+sizeof(RSZFile.InstanceInfos), FileSize()+48+instanceMethodSize+80);
    FixRCOLOffsets(80, groupInsertPt, FileSize()+48+instanceMethodSize+80);

    ReadBytes(buffer, requestSetInsertPt-48, 48);
    InsertBytes(requestSetInsertPt, 48, 0);
    WriteBytes(buffer, requestSetInsertPt, 48);
    
    WriteUInt(requestSetInsertPt, RequestSets.RequestSet[Header.numRequestSets-1].RequestSetInfo.ID+1);
    WriteUInt(requestSetInsertPt+4, Header.numGroups);
    WriteUInt64(requestSetInsertPt+16, FileSize()+2+80+instanceMethodSize);
    WriteInt(requestSetInsertPt+24, hash_wide((string)nameString));
    WriteUInt64(requestSetInsertPt+32, FileSize()+80+instanceMethodSize);
    WriteUInt(requestSetInsertPt+40, 0x81F16F39); //no-name hash for the keyhash
    InsertBytes(FileSize(), sizeof(nameString)+2, 0);
    WriteWString(FileSize()-sizeof(nameString), nameString);
    newInstancesInsertPt = FindFirst("RSZ")+4;
    InsertBytes(newInstancesInsertPt, instanceMethodSize, 0);
    WriteBytes(newInstanceBytes, newInstancesInsertPt, instanceMethodSize);
    Header.numGroups += 1;
    Header.numRequestSets += 1;
    
    local wstring grpNameString = InputString("Insert RequestSet (Group)", "Input a new name for your RequestSet's Group", "NewGroup");
    ReadBytes(buffer, groupInsertPt-80, 80);
    InsertBytes(groupInsertPt, 80, 0); 
    WriteBytes(buffer, groupInsertPt, 80);
    WriteRandomGUID(groupInsertPt);
    WriteUInt64(groupInsertPt+16, FileSize());
    WriteInt(groupInsertPt+24, hash_wide((string)grpNameString));
    WriteInt(groupInsertPt+32, 0);
    WriteInt64(groupInsertPt+40, 0);
    InsertBytes(FileSize(), sizeof(grpNameString), 0);
    WriteWString(FileSize()-sizeof(grpNameString), grpNameString);
    WriteRandomGUID(groupInsertPt+64);
}

int getCombinedKeysInstanceCount(string s) {
    local short ctr;
    local short index = findS(s, " ");
    local short Arr[(sizeof(s)/8) + 2];
    local string tmp = s;
    while(index > -1) {
        tmp = StrDel(tmp, index, 1);
        index = findS(tmp, " ");
        ctr++;
    }
    return ctr;
}

void WriteNewShape(struct _GroupInfo &g, string s) {
    local uint shapeInsertPt = Groups.shapesEnd;
    local uint count = getCombinedKeysInstanceCount(s);
    local uint oldObjectCt = RSZFile[0].RSZHeader.objectCount;
    local string oldName = g.Name.String;
    local ubyte askForShape = true;
    local uchar buffer[160];
    local wstring shapeName;
    if (g.NumShapes)
        shapeInsertPt = g.ShapesTbl + 160 * g.NumShapes; 

    local uint instanceMethodSize = InstanceWriterMethod(s, 0, RSZFile[0].RSZHeader.instanceCount-1, 0, 2, 0);
    local char newInstanceBytes[instanceMethodSize];
    local uint newInstancesInsertPt = RSZOffset+52;

    ReadBytes(newInstanceBytes, newInstancesInsertPt, instanceMethodSize);
    DeleteBytes(newInstancesInsertPt, instanceMethodSize);
   
    FixRCOLOffsets(instanceMethodSize, RSZOffset+52, FileSize()+instanceMethodSize);
    FixRCOLOffsets(160*count, shapeInsertPt, FileSize()+instanceMethodSize+160*count);
    newInstancesInsertPt = FindFirst("RSZ")+52;
    
    InsertBytes(newInstancesInsertPt, instanceMethodSize, 0);
    WriteBytes(newInstanceBytes, newInstancesInsertPt, instanceMethodSize);
    
    ReadBytes(buffer, Groups.shapesEnd-160, 160);
    InsertBytes(shapeInsertPt, count * 160, 0);
    for (h=0; h<count; h++) {
        WriteBytes(buffer, shapeInsertPt + h*160, 160);
        WriteRandomGUID(shapeInsertPt+h*160);
        if (askForShape == true) {
            shapeName = InputString("Insert Shape", "Input a new name for your Shape", " ");
            if (shapeName == " ")
                shapeName == "";
            else if (shapeName != "") {
                WriteUInt64(shapeInsertPt+h*160+16, FileSize());
                InsertBytes(FileSize(), sizeof(shapeName), 0);
                WriteWString(FileSize()-sizeof(shapeName), shapeName);
                WriteInt(shapeInsertPt+h*160+24, hash_wide((string)shapeName));
            } else
                askForShape = false;
        }
        WriteInt(shapeInsertPt+h*160+28, oldObjectCt+h); //UserDataIndex
    }
    if (g.NumShapes == 0)
        g.ShapesTbl = shapeInsertPt;
    
    g.NumShapes += count;
}

string ReadRequestSetWriterMessage(ubyte &r) { return "      [Input CombinedKeys here to add a RequestSet]"; }

string ReadShapeWriterMessage(struct _GroupInfo &g) { return "      [Input CombinedKeys here to add Shapes]"; }

string ReadGroupCombinedKeys( ubyte &g) {  
    local string chain;
    for (h=0; h<parentof(parentof(g)).GroupInfo.NumShapes; h++) {
        if (exists(parentof(parentof(g)).Shape[h]) && parentof(parentof(g)).Shape[h].ShapeInfo.UserDataIndex >= 0 
        && exists(RSZFile.ObjectTable[parentof(parentof(g)).Shape[h].ShapeInfo.UserDataIndex])) 
            chain += ReadCombinedKey(RSZFile.InstanceInfos.instanceInfo[RSZFile.ObjectTable[parentof(parentof(g)).Shape[h].ShapeInfo.UserDataIndex]].CombinedKey);
    }
    return chain; 
}

string readRequestSetInfoCombinedKey( struct _RequestSetInfo &r) {  
    local string chain;
    h=RSZFile[0].ObjectTable[r.Index];
    while(h > 0 && exists(RSZFile[0].Data.RawData.RSZ[h])) {
        if (h != RSZFile[0].ObjectTable[r.Index] && RSZFile[0].InstanceInfos.instanceInfo[h].isObject)
            break;
        chain = ReadCombinedKey(RSZFile[0].InstanceInfos.instanceInfo[h].CombinedKey) + chain;
        h--;
    }
    return chain; 
}


//RCOL only =======================================================
if (ReadUInt(0) == id_RCOL) { 
    FSeek(Header.groupsPtrTbl);
    struct {
        local uint shapesEnd <hidden=true>;
        typedef struct {
            struct _GroupInfo {
                ubyte CombinedKeys <read=ReadGroupCombinedKeys>;
                FSkip(-1);
                rGUID Guid;
                StringRead Name(-1, 0, 0);
                uint NameHash <format=hex>;
                int UserDataIndex;
                int NumShapes;
                int NumMaskGuids;
                uint64 ShapesTbl;
                int LayerIndex;
                uint MaskBits;
                uint64 MaskGuidsOffset;
                rGUID LayerGuid;
                if (NumMaskGuids) {
                    FSeek(MaskGuidsOffset);
                    rGUID MaskGuids[NumMaskGuids] <optimize=false>;
                    FSeek(startof(LayerGuid)+16);
                }
            } GroupInfo <read=ReadShapeWriterMessage, write=WriteNewShape, name="[GroupInfo]">;
            
            FSeek(GroupInfo.ShapesTbl);
            if (GroupInfo.NumShapes)
                struct RcolShape {
                    struct RcolShapeInfo {
                        rGUID Guid;
                        StringRead Name(-1, 0, 0);
                        uint NameHash <format=hex>;
                        int UserDataIndex;
                        int LayerIndex;
                        int Attribute;
                        uint SkipIdBits;
                        uint IgnoreTagBits;
                        StringRead primaryJointNameStr(-1, 0, 0);
                        StringRead secondaryJointNameStr(-1, 0, 0);
                        uint PrimaryJointNameHash <format=hex>;
                        uint SecondaryJointNameHash <format=hex>;
                    } ShapeInfo <name="[ShapeInfo]", read=ReadRcolShapeInfo>;
            
                    enum <uint32> {
                        ShapeType_Aabb = 0x0,
                        ShapeType_Sphere = 0x1,
                        ShapeType_ContinuousSphere = 0x2,
                        ShapeType_Capsule = 0x3,
                        ShapeType_ContinuousCapsule = 0x4,
                        ShapeType_Box = 0x5,
                        ShapeType_Mesh = 0x6,
                        ShapeType_HeightField = 0x7,
                        ShapeType_StaticCompound = 0x8,
                        ShapeType_Area = 0x9,
                        ShapeType_Triangle = 0xA,
                        ShapeType_SkinningMesh = 0xB,
                        ShapeType_Cylinder = 0xC,
                        ShapeType_DeformableMesh = 0xD,
                        ShapeType_Invalid = 0xE,
                        ShapeType_Max = 0xF,
                    } ShapeType;
                    
                    FSkip(4);
                    struct {
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                    } Parameters;
                    if (FTell() > Groups.shapesEnd)
                        Groups.shapesEnd = FTell();
                    if (ShapeInfo.UserDataIndex >= 0 && exists(RSZFile[0].ObjectTable[ShapeInfo.UserDataIndex])) {
                        local ushort ObjectIndex <hidden=true> = RSZFile[0].ObjectTable[ShapeInfo.UserDataIndex];
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[ObjectIndex]));
                        struct RSZInstance RSZ <size=SizeRSZInstance>;
                        FSeek(startof(Parameters)+80);
                    }
                } Shape[GroupInfo.NumShapes] <read=ReadShape, optimize=false>; 
                
            FSeek(startof(GroupInfo.LayerGuid)+16);
            checkUseSpacers();

        } RcolGroup <read=ReadGroup>; 
        struct RcolGroup Group[Header.numGroups] <optimize=false>; //size=80, 
    } Groups;

    if (exists(Header.numRequestSets) && Header.numRequestSets) {
        FSeek(Header.requestSetTbl);
        struct {
            ubyte RequestSetWriter <read=ReadRequestSetWriterMessage, write=WriteNewRequestSet>; FSkip(-1);
            local uint rcolArr[Header.numRequestSets] <hidden=true>;
            local uint rcolOffsetsArr[Header.numRequestSets] <hidden=true>;
            for (n=0; n<Header.numRequestSets; n++) { 
                rcolArr[n] = ReadUInt(); 
                rcolOffsetsArr[n] = FTell(); 
                FSkip(48); 
            }
            if (SortRequestSets)
                quicksort(0, Header.numRequestSets-1, rcolArr, rcolOffsetsArr); //Sort RequestSets by their IDs
            
            FSeek(Header.requestSetTbl);
            local uint endRequestSets <hidden=true>;
            for (n=0; n<Header.numRequestSets; n++) {
                FSeek(rcolOffsetsArr[n]);
                struct RcolRequestSet {
                    struct _RequestSetInfo {
                        local ushort Index = (startof(this) - startof(RequestSets)) / 48;
                        uint ID;
                        int GroupIndex;
                        int ShapeOffset;
                        uint status;
                        StringRead Name(-1, 0, 0);
                        uint NameHash <format=hex>;
                        FSkip(4);
                        StringRead KeyName(-1, 0, 0);
                        uint KeyHash <format=hex>;
                    } RequestSetInfo <name="[RequestSetInfo]", read=readRequestSetInfoCombinedKey>;
                    local ushort ObjectIndex <hidden=true> = RSZFile.ObjectTable[RequestSetInfo.Index];
                    FSeek(startof(Groups.Group[RequestSetInfo.GroupIndex]));
                    struct RcolGroup Group <size=80>;
                    
                    FSeek(startof(RSZFile.Data.RawData.RSZ[ObjectIndex]));
                    struct RSZInstance RSZ <size=SizeRSZInstance>;
                    
                    FSeek(startof(this)+48);
                } RequestSet <size=48, name=ReadRequestSetName, read=ReadRequestSet>;
                if (FTell() > endRequestSets) endRequestSets = FTell();
            }
            FSeek(endRequestSets);
        } RequestSets;
    }
} 

    wstring ReadGroup(RcolGroup &g) { return ReadWString(ReadUInt64(startof(g)+16)); }

    wstring ReadShape(RcolShape &s) { return s.ShapeInfo.Name.String; } 

    wstring ReadRequestSet(RcolRequestSet &a) { return ReadWString(ReadUInt(startof(a)+16)); }

    wstring ReadRequestSetName(RcolRequestSet &a) { string s; SPrintf(s, "RequestSet ID: %u  ", ReadUInt(startof(a))); return s; }

    wstring ReadRcolShapeInfo(RcolShapeInfo &r) { return r.primaryJointNameStr.String + "  " + r.secondaryJointNameStr.String; }


//fix headerstrings array
if (BHVTStart == -1 && headerStringsCount > 0) {
    quicksort(0, headerStringsCount-1, headerStrings, dummyArr);
    temp = headerStrings[headerStringsCount-1] + sizeof(ReadWString(headerStrings[headerStringsCount-1]));
    while(temp < RSZOffset && !detectedString(temp))
        temp++;
    if (temp < RSZOffset) {
        headerStrings[headerStringsCount] = temp;
        headerStringsCount++;
    }
    headerStrings[headerStringsCount] = headerStrings[headerStringsCount-1] + sizeof(ReadWString(headerStrings[headerStringsCount-1]));
    if (headerStrings[0] == 0)
        headerStrings[0] = startof(Header)+sizeof(Header);
}
FSeek(FileSize()); 
FSkip(-1); 
BLANK ____; //to quickly get to end of file from template results
if (exists(ResourceInfos.noResourceInfoOutput) && ResourceInfos.noResourceInfoOutput != "") //
    Printf("\nMissing ResourceInfos:%s\n", ResourceInfos.noResourceInfoOutput);